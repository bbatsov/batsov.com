I"|3<p>Today we’ll talk about attributes in Ruby.</p>

<p>Let’s start with the following rule from the
<a href="https://github.com/rubocop-hq/ruby-style-guide">Ruby Style Guide</a>:</p>

<blockquote>
  <p>Use the <code class="language-plaintext highlighter-rouge">attr</code> family of functions to define trivial accessors or mutators.</p>
</blockquote>

<p>Everyone who’s coded a bit of Ruby knows it’s preferable to generate
trivial reader and writer methods via some metaprogramming magic
instead of writing them by hand. The methods from <code class="language-plaintext highlighter-rouge">Module</code> <code class="language-plaintext highlighter-rouge">attr</code>,
<code class="language-plaintext highlighter-rouge">attr_reader</code>, <code class="language-plaintext highlighter-rouge">attr_writer</code> and <code class="language-plaintext highlighter-rouge">attr_accessor</code> do exactly that kind
of magic. Here’s an example using <code class="language-plaintext highlighter-rouge">attr_reader</code>:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># bad</span>
<span class="k">class</span> <span class="nc">Person</span>
  <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="n">first_name</span><span class="p">,</span> <span class="n">last_name</span><span class="p">)</span>
    <span class="vi">@first_name</span> <span class="o">=</span> <span class="n">first_name</span>
    <span class="vi">@last_name</span> <span class="o">=</span> <span class="n">last_name</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">first_name</span>
    <span class="vi">@first_name</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">last_name</span>
    <span class="vi">@last_name</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="c1"># good</span>
<span class="k">class</span> <span class="nc">Person</span>
  <span class="nb">attr_reader</span> <span class="ss">:first_name</span><span class="p">,</span> <span class="ss">:last_name</span>

  <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="n">first_name</span><span class="p">,</span> <span class="n">last_name</span><span class="p">)</span>
    <span class="vi">@first_name</span> <span class="o">=</span> <span class="n">first_name</span>
    <span class="vi">@last_name</span> <span class="o">=</span> <span class="n">last_name</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>Here’s <code class="language-plaintext highlighter-rouge">attr_writer</code> in action:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># bad</span>
<span class="k">class</span> <span class="nc">Person</span>
  <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="nb">name</span><span class="p">,</span> <span class="nb">name</span><span class="p">)</span>
    <span class="vi">@name</span> <span class="o">=</span> <span class="nb">name</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">name</span><span class="o">=</span><span class="p">(</span><span class="nb">name</span><span class="p">)</span>
    <span class="vi">@name</span> <span class="o">=</span> <span class="nb">name</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="c1"># good</span>
<span class="k">class</span> <span class="nc">Person</span>
  <span class="nb">attr_writer</span> <span class="ss">:name</span>

  <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="nb">name</span><span class="p">)</span>
    <span class="vi">@name</span> <span class="o">=</span> <span class="nb">name</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">attr_accessor</code> combines the two:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># bad</span>
<span class="k">class</span> <span class="nc">Person</span>
  <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="nb">name</span><span class="p">,</span> <span class="nb">name</span><span class="p">)</span>
    <span class="vi">@name</span> <span class="o">=</span> <span class="nb">name</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">name</span>
    <span class="vi">@name</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">name</span><span class="o">=</span><span class="p">(</span><span class="nb">name</span><span class="p">)</span>
    <span class="vi">@name</span> <span class="o">=</span> <span class="nb">name</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="c1"># good</span>
<span class="k">class</span> <span class="nc">Person</span>
  <span class="nb">attr_accessor</span> <span class="ss">:name</span>

  <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="nb">name</span><span class="p">)</span>
    <span class="vi">@name</span> <span class="o">=</span> <span class="nb">name</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>Pretty sure none of you has learned anything new at this point. Now we start with the fun part…</p>

<p>How many of you know how <code class="language-plaintext highlighter-rouge">attr</code> behaves? Are you totally sure? Let’s
see what the style guide says about it:</p>

<blockquote>
  <p>Avoid the use of <code class="language-plaintext highlighter-rouge">attr</code>. Use <code class="language-plaintext highlighter-rouge">attr_reader</code> and <code class="language-plaintext highlighter-rouge">attr_accessor</code> instead.</p>
</blockquote>

<p><code class="language-plaintext highlighter-rouge">attr</code>’s behavior changed between Ruby 1.8 and 1.9. In Ruby 1.8 <code class="language-plaintext highlighter-rouge">attr</code>
created a single <em>reader</em> method. With an optional second boolean argument it
created both a <em>reader</em> and a <em>writer</em> method (a la <code class="language-plaintext highlighter-rouge">attr_accessor</code>).</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Ruby 1.8</span>
<span class="c1"># same as attr_reader :something</span>
<span class="kp">attr</span> <span class="ss">:something</span>

<span class="c1"># creates a single attribute accessor (deprecated in 1.9) - same as attr_accessor :something</span>
<span class="kp">attr</span> <span class="ss">:something</span><span class="p">,</span> <span class="kp">true</span>

<span class="c1"># can't do this</span>
<span class="kp">attr</span> <span class="ss">:one</span><span class="p">,</span> <span class="ss">:two</span><span class="p">,</span> <span class="ss">:three</span>
</code></pre></div></div>

<p>Note that you cannot pass multiple attribute names to <code class="language-plaintext highlighter-rouge">attr</code> in Ruby 1.8.</p>

<p>In Ruby 1.9 calling <code class="language-plaintext highlighter-rouge">attr</code> with an attribute name and a boolean is
deprecated and it now behaves a lot more like <code class="language-plaintext highlighter-rouge">attr_reader</code>.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Ruby 1.9</span>
<span class="kp">attr</span> <span class="ss">:one</span><span class="p">,</span> <span class="ss">:two</span><span class="p">,</span> <span class="ss">:three</span> <span class="c1"># behaves as attr_reader</span>
</code></pre></div></div>

<p>Given all this facts it’s not a surprise that so many people think
it’s a bad idea to use <code class="language-plaintext highlighter-rouge">attr</code>. I guess if the design of that portion
of the API were up to me I’d have made <code class="language-plaintext highlighter-rouge">attr</code> behave like
<code class="language-plaintext highlighter-rouge">attr_accessor</code> from day 1. The name of <code class="language-plaintext highlighter-rouge">attr_accessor</code> is a bit of a
misnomer since <code class="language-plaintext highlighter-rouge">accessor</code> is hardly a synonym for <strong>reader and
writer</strong>. Anyways, this is not of particular importance. Off to the
next item on our agenda for today.</p>

<p>Is this something that should have been defined with <code class="language-plaintext highlighter-rouge">attr_reader</code>?</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">something</span>
  <span class="vi">@something_else</span>
<span class="k">end</span>
</code></pre></div></div>

<p>Basically it call comes down to whether this is a trivial reader method or not.
Some people would argue that because the name of the instance variable
and the name of the method are not the same - it’s not. I’d argue the
opposite case - it is! The name of the method does not change the
semantics. In essence you’re simply in need of an alias for the
<em>default</em> attribute reader method:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">attr_reader</span> <span class="ss">:something_else</span>
<span class="kp">alias_method</span> <span class="ss">:something</span><span class="p">,</span> <span class="ss">:something_else</span>
</code></pre></div></div>

<p>Boolean attributes are a bit special, since generally we’d like to
have a <code class="language-plaintext highlighter-rouge">?</code> at the end of predicate method names, but this cannot be done with
<code class="language-plaintext highlighter-rouge">attr_reader/attr_accessor</code>. Some people would simple hand-code such
methods:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">something?</span>
  <span class="vi">@something</span>
<span class="k">end</span>
</code></pre></div></div>

<p>I’d employ <code class="language-plaintext highlighter-rouge">alias_method</code> again:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>attr_reader :something
alias_method :something?, :something
</code></pre></div></div>

<p>I wouldn’t call one style necessary good or bad - it’s more of a personal preference.</p>

<p>One final note - you should use <code class="language-plaintext highlighter-rouge">attr_</code> only for trivial reader and writer methods (trivial means that
they do not need any defensive copying or pre-update checks).</p>

<p>Consider this:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># attr_reader generates code like this</span>
<span class="k">def</span> <span class="nf">something</span>
  <span class="vi">@something</span>
<span class="k">end</span>
</code></pre></div></div>

<p>This would expose <code class="language-plaintext highlighter-rouge">@something</code> to external modifications if it’s a
mutable object. To shield yourself from this you can use defensive
copying (or freezing when applicable):</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># defensive copying in action</span>
<span class="k">def</span> <span class="nf">something</span>
  <span class="vi">@something</span><span class="p">.</span><span class="nf">dup</span> <span class="c1"># return a copy of @something</span>
<span class="k">end</span>
</code></pre></div></div>

<p>Same goes for attributes writers. If you have an <code class="language-plaintext highlighter-rouge">age</code> attribute and you
want to enforce that it should be a positive number you’d generally roll your
own writer:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">age</span><span class="o">=</span><span class="p">(</span><span class="n">age</span><span class="p">)</span>
  <span class="nb">fail</span> <span class="s1">'Age should be a positive number!'</span> <span class="k">unless</span> <span class="n">age</span> <span class="o">&gt;</span> <span class="mi">0</span>

  <span class="vi">@age</span> <span class="o">=</span> <span class="n">age</span>
<span class="k">end</span>
</code></pre></div></div>

<p>This post has become way too long, so I’ll be wrapping it up. I hope
you’ve found my musing on the subject of attributes useful.</p>

<p>As usual I’m looking forward to hearing your thoughts here and on
<a href="http://twitter.com/bbatsov">Twitter</a>!</p>

<p><strong>P.S.</strong> Happy 4th of July to all my American readers!</p>
:ET