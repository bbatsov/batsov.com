I"⁄l<h2 id="prelude">Prelude</h2>

<p>This is the third part of the series of <strong>Java.next()</strong>. Last time
we‚Äôve discussed the merits of <a href="/Java/Scala/2011/05/08/jvm-langs-scala.html">Scala</a> - an OO language with a strong
emphasis on functional and parallel programming. Today we‚Äôll be
discussing Clojure - a language that pushes the envelop a lot further
than Scala as far as functional and parallel programming are
concerned. You‚Äôll see that Clojure is radically different from Scala
and Groovy in many aspects - it‚Äôs not an OO language, it doesn‚Äôt have
Algol-derived syntax and it introduces a few rather radical ideas on
subjects such as <a href="http://clojure.org/state">identity and state</a>.</p>

<p>Clojure‚Äôs approach to concurrency is characterized by the concept of
identities, which represent a series of immutable states over
time. Since states are immutable values, any number of workers can
operate on them in parallel, and concurrency becomes a question of
managing changes from one state to another. For this purpose, Clojure
provides several mutable reference types, each having well-defined
semantics for the transition between states. This is a pretty complex
topic for a language overview so I‚Äôll discuss it here only cursory.</p>

<p>Clojure was initially conceived as targeting both the JVM and the
CLR. For various reason currently the core development team is targeting mainly
the JVM and the <a href="https://github.com/richhickey/clojure-clr">CLR port</a>
is receiving less attention (though it‚Äôs not abandoned and it‚Äôs
regularly being updated). Like Scala it‚Äôs not technically correct to
call it a JVM languages, because it‚Äôs both a JVM and a .Net language,
but since it‚Äôs used a lot more often with Java it doesn‚Äôt make that
much of a difference.</p>

<h2 id="a-brief-history-of-clojure">A brief history of Clojure</h2>

<p>Clojure is a very young project (compared to most popular
programming languages at least). It was created in 2007 by Rich
Hickey (project leader and benevolent dictator for life). He developed
Clojure because he wanted a modern Lisp for functional programming,
symbiotic with the established Java platform, and designed for
concurrency. What started as a hobby project turned into some much
bigger with Rich getting so excited about the project that left his
job to work full-time on the project, effectively through burning his life‚Äôs
savings in the process. This was quite the gamble, but it turned out
to be a lucky one, since Clojure‚Äôs popularity rapidly spiked and
loyal and energetic community was quickly formed around the project.</p>

<p>Clojure became the new language of choice for many well respected
hackers from different communities. I‚Äôve noticed something of a trend
in that department - most Clojure hackers used to be Ruby hackers. I
guess some of the Ruby hackers were not satisfied by partial subset of
Lisp features, available in Ruby, and wanted to gain access to all of
Lisp‚Äôs power.</p>

<p>The current Clojure version is 1.2 with 1.3 being just around the
corner.</p>

<h2 id="installing-clojure">Installing Clojure</h2>

<p><em>Before installing Clojure make sure you have Java installed. Java 5.0
SE will do, but Java 6 SE is highly recommended.</em></p>

<p>Installing Clojure is just a matter of downloading and extracting a
single archive -
<a href="http://github.com/downloads/clojure/clojure/clojure-1.2.0.zip">clojure.zip</a>. Many
high quality Clojure libraries come prepackaged in another archived
named
<a href="http://github.com/downloads/clojure/clojure-contrib/clojure-contrib-1.2.0.zip">Clojure Contrib</a>. Clojure
Contrib is kind of a staging area for Clojure development - it‚Äôs a
common practice to move some of the best parts of contrib into core.</p>

<p>In the directory in which you expanded clojure.zip, run:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>java <span class="nt">-cp</span> clojure.jar clojure.main
</code></pre></div></div>

<p>This will bring up a simple read-eval-print loop (REPL) a.k.a. an
interactive console. Much of
Clojure is defined in Clojure itself (in the <strong>core.clj</strong> file included in
the src directory of distribution), which is automatically loaded from
the .jar file when Clojure starts. The file <strong>user.clj</strong>, if found in the
classpath, will be auto-loaded as well. You can leverage this to cause
code to run when Clojure starts. Reading the code in core.clj is a
very good way to get started with language and see how real Clojure
hackers work.</p>

<p>When core.clj is loaded you will have the language as described herein fully available.
Try:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">user=&gt;</span><span class="w"> </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span><span class="w">
</span><span class="mi">6</span><span class="w">
</span><span class="n">user=&gt;</span><span class="w"> </span><span class="p">(</span><span class="nb">println</span><span class="w"> </span><span class="s">"Hello, Clojure!"</span><span class="p">)</span><span class="w">
</span><span class="n">Hello,</span><span class="w"> </span><span class="n">Clojure!</span><span class="w">
</span><span class="n">nil</span><span class="w">
</span><span class="n">user=&gt;</span><span class="w"> </span><span class="p">(</span><span class="nf">javax.swing.JOptionPane/showMessageDialog</span><span class="w"> </span><span class="n">nil</span><span class="w"> </span><span class="s">"Hello World"</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>The REPL has very rudimentary editing. For a better experience, try running it via the <a href="http://jline.sourceforge.net/">JLine</a> ConsoleRunner:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>java <span class="nt">-cp</span> jline-0_9_5.jar:clojure.jar jline.ConsoleRunner clojure.main
</code></pre></div></div>

<p>This will give you left/right arrow key navigation and up/down arrow
command history.</p>

<p>Later on we‚Äôll see how to setup a real Clojure development environment
in which you‚Äôll be able to leverage the full power of the Clojure REPL
and interactive programming.</p>

<h2 id="did-you-say-clojure-was-a-lisp">Did you say Clojure was a Lisp???</h2>

<p>Most developers tend to have a very negative attitude towards the word
<strong>Lisp</strong> in general. I guess it spawns all kinds of nasty associations in
their brains - like prefix syntax notation, tons of parentheses and a
lot of crap they heard about Lisp from their 70 year-old professor,
teaching introduction to functional programming in college, whose
notion of functional programming is that in Lisp everything is a
function (believe me when I tell you this - such professors do exist).</p>

<p>You know, I wasn‚Äôt born coding in Lisp myself. I was initially
exposed to Lisp when I tried to learn the Emacs text editor and I was
baffled by many things - the strange syntax, the talk about atoms and
lists, code as data, macros, continuation, tail-call optimizations,
what to quote and that to evaluate, what is a s-expression and what
isa form. To put it shortly - I was like
Alice down the rabbit whole or like Neo when he found out what the
Matrix is‚Ä¶ The world of programming that I was familiar with was
turned upside down.</p>

<p>The interesting thing is that I felt similarly when I learnt my first
programming language Pascal in the 8th grade. It‚Äôs not that Lisp is
any harder than the other programming languages - it‚Äôs just that it‚Äôs
different and you‚Äôre usually approaching it from a position in which
you know one or several programming languages, using the much more
widespread Algol syntax. I advise you to simply keep an open mind while
you read this article and don‚Äôt just dismiss Clojure because of its
Lisp heritage.</p>

<p>You likely know at least one person who constantly keeps telling
you how Lisp is the one true programming language, how everything
pales next to it and how Lisp is the actual answer to that fundamental
question about the life, the universe and everything else (not
42). These people might very well be telling the truth, but their
zealous rants tend to create a negative attitude towards the Lisp
community as well. Please, ignore them.</p>

<p>Now it‚Äôs time to take the red pill‚Ä¶ So fasten your seat-belt
Dorothy, ‚Äòcause Kansas is going bye-bye!</p>

<h2 id="clojure-at-a-glance">Clojure at a glance</h2>

<blockquote>
  <p>Mutable state is the new spaghetti code!</p>

  <p>‚ÄìRich Hickey, creator of Clojure</p>
</blockquote>

<blockquote>
  <p>Time is the new memory!</p>

  <p>‚ÄìRich Hickey, creator of Clojure</p>
</blockquote>

<blockquote>
  <p>Clojure feels like a general-purpose language beamed back from the
near future. Its support for functional programming and software
transactional memory is well beyond current practice and is well
suited for multicore hardware. At the same time, Clojure is well
grounded in the past and the present. It brings together Lisp and the
Java Virtual Machine. Lisp brings wisdom spanning most of the history
of programming, and Java brings the robustness, extensive libraries,
and tooling of the dominant platform available today.</p>

  <p>‚ÄìStuart Halloway, author of ‚ÄúProgramming Clojure‚Äù</p>
</blockquote>

<p>If I had only a few minutes to describe Clojure this would be the gist
of it:</p>

<ul>
  <li>Dynamic language for the JVM
    <ul>
      <li>Clojure uses dynamic typing like languages such Ruby and Python
and a very smart compiler that will generally generate very
efficient bytecode. If you want to push the performance envelope even
further you can add some explicit type hints in your Clojure
code to ensure the generation of even faster bytecode.</li>
    </ul>
  </li>
  <li>Lisp reloaded
    <ul>
      <li>Clojure is Lisp down to its core - it has all the features that
are known and loved, and in the same time it improves upon them in
several ways - for instance we have a literal syntax for most
common collection types. Sure - with Common Lisp‚Äôs reader macros
one can do this as well, but nobody bothers to‚Ä¶</li>
    </ul>
  </li>
  <li>Elegant
    <ul>
      <li>Clojure code tends to be very concise, but very readable non the
less. A core idea in Clojure is to strip the incidental
complexity of problems solving and to be able to just solve the
problems straight away without much ceremony.</li>
    </ul>
  </li>
  <li>Functional
    <ul>
      <li>Clojure puts heavy emphasis on functional programming, but it‚Äôs
a practical functional programming language - not a pure one
like Haskell. Clojure acknowledges that some stuff simply change
and operations have to generally produce some effects, and makes
those things easy to model. Clojure has a library full of
rock-solid immutable data structures, relies heavily on lazy
evaluation, tail-recursion and higher-order functions.</li>
    </ul>
  </li>
  <li>Designed with concurrency in mind
    <ul>
      <li>Clojure has an extensive built-in high-level facilities to deal
with concurrent access to data and parallel programming in general.</li>
    </ul>
  </li>
  <li>Fast
    <ul>
      <li>Unlike many dynamic languages (even those running on top the
JVM) Clojure is quite fast - it some scenarios it‚Äôs performance
can rival that of a statically type language. You can browse a
long list of
<a href="http://stackoverflow.com/questions/2186709/are-there-any-good-clojure-benchmarks">benchmark comparisons</a>
to verify this statement. Given the fact that performance if
often cited as a big drawback of dynamic languages, this is
quite the win for Clojure.</li>
    </ul>
  </li>
  <li>Capable of easily leveraging existing Java code
    <ul>
      <li>Using Java code from Clojure is direct, easy and
idiomatic. There are no intermediate layers or the need to
write wrapper for everything.</li>
    </ul>
  </li>
</ul>

<p>I‚Äôll discuss in greater detail some of those features as I moving along.</p>

<h2 id="a-whirlwind-tour-of-clojure">A whirlwind tour of Clojure</h2>

<h4 id="clojure-is-elegant">Clojure is elegant</h4>

<ul>
  <li>Removes a lot of accidental complexity</li>
  <li>Clojure programs are generally expressive and concise</li>
  <li>Concise programs are naturally easier to understand and maintain</li>
</ul>

<p>Consider this Java example from our Scala discussion:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">public</span><span class="w"> </span><span class="nb">boolean</span><span class="w"> </span><span class="n">hasUpperCase</span><span class="p">(</span><span class="nf">String</span><span class="w"> </span><span class="n">word</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nf">word</span><span class="w"> </span><span class="nb">==</span><span class="w"> </span><span class="n">null</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
        </span><span class="n">return</span><span class="w"> </span><span class="n">false</span><span class="c1">;</span><span class="w">
    </span><span class="p">}</span><span class="w">
    </span><span class="nb">int</span><span class="w"> </span><span class="n">len</span><span class="w"> </span><span class="nb">=</span><span class="w"> </span><span class="n">word.length</span><span class="p">()</span><span class="c1">;</span><span class="w">
    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="nb">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="nb">=</span><span class="w"> </span><span class="mi">0</span><span class="c1">; i &lt; len; i++) {</span><span class="w">
        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nf">Character.isUpperCase</span><span class="p">(</span><span class="nf">word.charAt</span><span class="p">(</span><span class="nf">i</span><span class="p">)))</span><span class="w"> </span><span class="p">{</span><span class="w">
            </span><span class="n">return</span><span class="w"> </span><span class="n">true</span><span class="c1">;</span><span class="w">
        </span><span class="p">}</span><span class="w">
    </span><span class="p">}</span><span class="w">
    </span><span class="n">return</span><span class="w"> </span><span class="n">false</span><span class="c1">;</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<p>As a reader pointed out using the third party Guava library the code
can be reduced to:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">public</span><span class="w"> </span><span class="nb">boolean</span><span class="w"> </span><span class="n">hasUpperCase</span><span class="p">(</span><span class="nf">String</span><span class="w"> </span><span class="n">word</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nf">null</span><span class="w"> </span><span class="n">!=</span><span class="w"> </span><span class="n">word</span><span class="p">)</span><span class="w">
        </span><span class="n">return</span><span class="w"> </span><span class="n">any</span><span class="p">(</span><span class="nf">charactersOf</span><span class="p">(</span><span class="nf">word</span><span class="p">)</span><span class="n">,</span><span class="w"> </span><span class="nb">new</span><span class="w"> </span><span class="n">Predicate</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
                </span><span class="n">public</span><span class="w"> </span><span class="nb">boolean</span><span class="w"> </span><span class="nb">apply</span><span class="p">(</span><span class="nf">Character</span><span class="w"> </span><span class="n">c</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
                    </span><span class="n">return</span><span class="w"> </span><span class="n">isUpperCase</span><span class="p">(</span><span class="nf">c</span><span class="p">)</span><span class="c1">;</span><span class="w">
                </span><span class="p">}</span><span class="w">
            </span><span class="p">})</span><span class="w">
        </span><span class="n">else</span><span class="w">
            </span><span class="n">return</span><span class="w"> </span><span class="n">false</span><span class="c1">;</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<p>It still looks quite ugly to me. For the sake of comparison here‚Äôs the
Clojure version:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">has-uppercase?</span><span class="w"> </span><span class="p">[</span><span class="n">string</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nb">some</span><span class="w"> </span><span class="o">#</span><span class="p">(</span><span class="nf">Character/isUpperCase</span><span class="w"> </span><span class="n">%</span><span class="p">)</span><span class="w"> </span><span class="n">string</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>The definition of the problems is ‚ÄúA string has an uppercase character if
some of the characters in it is uppercase‚Äù (doesn‚Äôt sound good, but
will do). The Clojure code reads more or less like the definition of
the problem. A finer point is that it will work correctly even if you
pass <strong>nil</strong> to the has-uppercase? function.</p>

<h4 id="clojure-is-concise">Clojure is concise</h4>

<p>We already saw in the previous example the conciseness of Clojure
code, but here we‚Äôll add another example. This is Java:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">Person</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">name</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">age</span><span class="o">;</span>

    <span class="nc">Person</span><span class="o">(</span><span class="nc">String</span> <span class="n">name</span><span class="o">,</span> <span class="kt">int</span> <span class="n">age</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">name</span> <span class="o">=</span> <span class="n">name</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">age</span> <span class="o">=</span> <span class="n">age</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">getName</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">name</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setName</span><span class="o">(</span><span class="nc">String</span> <span class="n">name</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">name</span> <span class="o">=</span> <span class="n">name</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">getAge</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">age</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setAge</span><span class="o">(</span><span class="kt">int</span> <span class="n">age</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">age</span> <span class="o">=</span> <span class="n">age</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>In Clojure you‚Äôd probably model this class like this:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">user&gt;</span><span class="w"> </span><span class="p">(</span><span class="nf">defrecord</span><span class="w"> </span><span class="n">person</span><span class="w"> </span><span class="p">[</span><span class="nb">name</span><span class="w"> </span><span class="n">age</span><span class="p">])</span><span class="w">
</span><span class="n">user.person</span><span class="w">
</span><span class="n">user&gt;</span><span class="w"> </span><span class="p">(</span><span class="nf">person.</span><span class="w"> </span><span class="s">"Bozhidar"</span><span class="w"> </span><span class="mi">26</span><span class="p">)</span><span class="w">
</span><span class="o">#</span><span class="no">:user.person</span><span class="p">{</span><span class="no">:name</span><span class="w"> </span><span class="s">"Bozhidar"</span><span class="n">,</span><span class="w"> </span><span class="no">:age</span><span class="w"> </span><span class="mi">26</span><span class="p">}</span><span class="w">
</span><span class="n">user&gt;</span><span class="w"> </span><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">me</span><span class="w"> </span><span class="p">(</span><span class="nf">person.</span><span class="w"> </span><span class="s">"Bozhidar"</span><span class="w"> </span><span class="mi">26</span><span class="p">))</span><span class="w">
</span><span class="o">#</span><span class="ss">'user/me</span><span class="w">
</span><span class="n">user&gt;</span><span class="w"> </span><span class="p">(</span><span class="no">:name</span><span class="w"> </span><span class="n">me</span><span class="p">)</span><span class="w">
</span><span class="s">"Bozhidar"</span><span class="w">
</span><span class="n">user&gt;</span><span class="w"> </span><span class="p">(</span><span class="no">:age</span><span class="w"> </span><span class="n">me</span><span class="p">)</span><span class="w">
</span><span class="mi">26</span><span class="w">
</span></code></pre></div></div>

<p>Clojure‚Äôs version of the type is a one liner and remain shorter even
with a few examples of its usage. It‚Äôs not equivalent to Java
definition, however - the Clojure version of the structure is
immutable.</p>

<h4 id="clojure-is-a-lisp">Clojure is a Lisp</h4>

<p>For better or for worse Clojure is a Lisp dialect and we should accept
this. I have always viewed Lisp as weapon from a more elegant era when
people were more concerned with elements of style and empowering the
developers to easily translate their thoughts into programs. For one
reason or another every Lisp dialect has failed to capture the
attention of a critical mass of developers that may propel it into the
mainstream. This, of course, doesn‚Äôt mean that existing Lisp dialects
should be considered a failure. Scheme (the dialect that has probably
had the greatest impact on Clojure‚Äôs design) was designed to be as
simple as possible so it could be appropriate as a teaching tool - in
that area Scheme certainly excelled. Common Lisp was created to bring
together the various Lisp dialects under a common denominator and it
also excelled in that endeavour. I guess that its creators hoped that
it would capture a significant market share at some point as well, but alas -
that never happened.</p>

<p>The syntax and programming model of Lisp so far have been too much for
a typical developer to absorb. Yet, there‚Äôs something special about
Lisp that‚Äôs worth revisiting, so the new dialects continue to
emerge. Some of the best programming universities start teaching
programming with the Lisp language to form young minds while they are
still open. I have witnessed something of a cycle - every 5 or so
years the interest in Lisp spikes because of something major that
happened in the land of Lisp. In the beginning of the nineties the
work on Common Lisp excited a lot of developers. Five years later Paul
Graham took the stage - he showed the world how Lisp can empower small
teams and make real money (if you haven‚Äôt heard of Viaweb fire up
google now). Five years ago Peter Seibel published the
‚ÄúPractical Common Lisp‚Äù book that appeared on Amazon‚Äôs bestseller list
and got a lot of new developers excited about Lisp. A now‚Ä¶ well I
guess you can figure that one out on your own.</p>

<p>Lisp just won‚Äôt let go and die. There is something magical about
it. And there is this inexplicable smugness on the face of Lisp
developers‚Ä¶</p>

<p>So let‚Äôs review the typical Lisp features that are present in Clojure:</p>

<ul>
  <li>Lisp-1 dialect
    <ul>
      <li>This means that functions and variables share the same
namespace, unlike in dialects like Common Lisp. Both approaches
have their merits and drawbacks as usual. In Clojure you cannot
have a variable named the say way as a function, but you can
pass function names around without any special syntax. In Common
Lisp you can have function and variables sharing the same name,
but you have to mark functions explicitly when you‚Äôre passing
them around (with the #‚Äô reader macro or the <strong>function</strong> function).</li>
    </ul>
  </li>
  <li>Dynamic - both in term of dynamic typing and dynamic
development. Lisp is the language that made popular the technique of
incremental interactive development (we‚Äôll talk about it more in a bit)</li>
  <li>Code is data
    <ul>
      <li>List code is defined in term of Lisp data structures. When the
reader read the source code of the application it converts it to
standard Lisp objects and they represent the program. No special
transformations, no AST. This is the heart of Lisp macros and a
centrepiece in Lisp philosophy.</li>
    </ul>
  </li>
  <li>Reader
    <ul>
      <li>The reader can read valid Clojure forms and translate them into
Clojure objects - object, function call, everything that has a
readable representation</li>
    </ul>
  </li>
  <li>Small core, next to none syntax
    <ul>
      <li>In terms of compact syntax and uniformity of the syntax it has
always been hard to beat Lisp. Most programming languages are
full of special syntax constructs, keywords, etc. In lisp
programs are just lists and the low-level plumbing comes in the
form of special functions called special forms. Everything else
is implemented in terms of those special forms.</li>
    </ul>
  </li>
  <li>Sequences
    <ul>
      <li>Clojure abstracts common collection traits into an abstraction
called seq which allows you to use a similar API for many tasks</li>
    </ul>
  </li>
  <li>Macros
    <ul>
      <li>Forget about C macros, Word macros, editor macros. Lisp macros
are the most powerful metaprogramming technique out there - they
enable you generate new syntax abstractions unlike anything
else. If you need a new operator in Java you‚Äôd have a hard time
convincing the guys in Oracle to add it for you. With Lisp
you‚Äôre in charge and you can define any syntax abstractions that
you wish. As an appetiser consider the <strong>and</strong> boolean
statement. In most languages it‚Äôs built into the language
itself. In Clojure it‚Äôs just a short macro:</li>
    </ul>
  </li>
</ul>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defmacro</span><span class="w"> </span><span class="nb">and</span><span class="w">
  </span><span class="s">"Evaluates exprs one at a time, from left to right. If a form
  returns logical false (nil or false), and returns that value and
  doesn't evaluate any of the other expressions, otherwise it returns
  the value of the last expr. (and) returns true."</span><span class="w">
  </span><span class="p">{</span><span class="no">:added</span><span class="w"> </span><span class="s">"1.0"</span><span class="p">}</span><span class="w">
  </span><span class="p">([]</span><span class="w"> </span><span class="n">true</span><span class="p">)</span><span class="w">
  </span><span class="p">([</span><span class="n">x</span><span class="p">]</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w">
  </span><span class="p">([</span><span class="n">x</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="nb">next</span><span class="p">]</span><span class="w">
   </span><span class="o">`</span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="nb">and</span><span class="o">#</span><span class="w"> </span><span class="o">~</span><span class="n">x</span><span class="p">]</span><span class="w">
      </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="nb">and</span><span class="o">#</span><span class="w"> </span><span class="p">(</span><span class="nb">and</span><span class="w"> </span><span class="o">~@</span><span class="nb">next</span><span class="p">)</span><span class="w"> </span><span class="nb">and</span><span class="o">#</span><span class="p">))))</span><span class="w">
</span></code></pre></div></div>

<p>I hope this example gives you an idea about the power that Clojure
offers you - you can be more than just a programmer; you can be the
language designer.</p>

<h2 id="persistent-data-structures">Persistent data structures</h2>

<p>Data structures in Clojure are immutable. Operations executed on them
return a new data structure of the same type instead of modifying the
structure in place. Understandably most people are immediately
concerned about the performance implications of such a technique -
this seems like quite a lot of overhead. They needn‚Äôt worry, though.</p>

<p>Data structures in Clojure happen to be persistent as well. A persistent data
structure is a data structure which always preserves the previous
version of itself when it is modified -  such data structures are
effectively immutable, as their operations do not (visibly) update the
structure in-place, but instead always yield a new updated
structure. A persistent data structure is not a data structure
committed to persistent storage, such as a disk; this is a different
and unrelated sense of the word ‚Äúpersistent‚Äù.</p>

<p>Persistent data structures save a lot of copying around and improve
greatly the performance. Knowing this should be enough for most
developers, those that are more curious can find a lot of interesting
articles on the subject on-line.</p>

<p>The core data structures in Clojure are:</p>

<ul>
  <li>List</li>
  <li>Set - all the items in it are unique</li>
  <li>Map - also known as associative array and dictionary in other languages</li>
  <li>Vector - also know as one dimensional array</li>
</ul>

<p>Let‚Äôs see them in action:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">;;; Lists</span><span class="w">
</span><span class="c1">;; list creation</span><span class="w">
</span><span class="n">user&gt;</span><span class="w"> </span><span class="p">(</span><span class="nb">list</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span><span class="w">
</span><span class="p">(</span><span class="nf">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span><span class="w">
</span><span class="c1">;; quoted list creation</span><span class="w">
</span><span class="n">user&gt;</span><span class="w"> </span><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">a-list</span><span class="w"> </span><span class="o">'</span><span class="p">(</span><span class="nf">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="mi">6</span><span class="w"> </span><span class="mi">7</span><span class="w"> </span><span class="mi">8</span><span class="w"> </span><span class="mi">9</span><span class="w"> </span><span class="mi">10</span><span class="p">))</span><span class="w">
</span><span class="o">#</span><span class="ss">'user/a-list</span><span class="w">
</span><span class="c1">;; find the size of a list</span><span class="w">
</span><span class="n">user&gt;</span><span class="w"> </span><span class="p">(</span><span class="nb">count</span><span class="w"> </span><span class="n">a-list</span><span class="p">)</span><span class="w">
</span><span class="mi">10</span><span class="w">
</span><span class="n">user&gt;</span><span class="w"> </span><span class="p">(</span><span class="nb">first</span><span class="w"> </span><span class="n">a-list</span><span class="p">)</span><span class="w">
</span><span class="mi">1</span><span class="w">
</span><span class="n">user&gt;</span><span class="w"> </span><span class="p">(</span><span class="nb">rest</span><span class="w"> </span><span class="n">a-list</span><span class="p">)</span><span class="w">
</span><span class="p">(</span><span class="nf">2</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="mi">6</span><span class="w"> </span><span class="mi">7</span><span class="w"> </span><span class="mi">8</span><span class="w"> </span><span class="mi">9</span><span class="w"> </span><span class="mi">10</span><span class="p">)</span><span class="w">
</span><span class="n">user&gt;</span><span class="w"> </span><span class="p">(</span><span class="nb">last</span><span class="w"> </span><span class="n">a-list</span><span class="p">)</span><span class="w">
</span><span class="mi">10</span><span class="w">
</span><span class="c1">;; find the elements of the list matching a predicate(boolean function)</span><span class="w">
</span><span class="n">user&gt;</span><span class="w"> </span><span class="p">(</span><span class="nb">filter</span><span class="w"> </span><span class="n">even?</span><span class="w"> </span><span class="n">a-list</span><span class="p">)</span><span class="w">
</span><span class="p">(</span><span class="nf">2</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="mi">6</span><span class="w"> </span><span class="mi">8</span><span class="w"> </span><span class="mi">10</span><span class="p">)</span><span class="w">
</span><span class="n">user&gt;</span><span class="w"> </span><span class="p">(</span><span class="nb">filter</span><span class="w"> </span><span class="n">odd?</span><span class="w"> </span><span class="n">a-list</span><span class="p">)</span><span class="w">
</span><span class="p">(</span><span class="nf">1</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="mi">7</span><span class="w"> </span><span class="mi">9</span><span class="p">)</span><span class="w">
</span><span class="c1">;; map an anonymous(lambda) function to all elements of the list</span><span class="w">
</span><span class="n">user&gt;</span><span class="w"> </span><span class="p">(</span><span class="nb">map</span><span class="w"> </span><span class="o">#</span><span class="p">(</span><span class="nb">*</span><span class="w"> </span><span class="n">%</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="n">a-list</span><span class="p">)</span><span class="w">
</span><span class="p">(</span><span class="nf">2</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="mi">6</span><span class="w"> </span><span class="mi">8</span><span class="w"> </span><span class="mi">10</span><span class="w"> </span><span class="mi">12</span><span class="w"> </span><span class="mi">14</span><span class="w"> </span><span class="mi">16</span><span class="w"> </span><span class="mi">18</span><span class="w"> </span><span class="mi">20</span><span class="p">)</span><span class="w">
</span><span class="c1">;; add an element to the beginning of the list</span><span class="w">
</span><span class="n">user&gt;</span><span class="w"> </span><span class="p">(</span><span class="nb">cons</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="n">a-list</span><span class="p">)</span><span class="w">
</span><span class="p">(</span><span class="nf">0</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="mi">6</span><span class="w"> </span><span class="mi">7</span><span class="w"> </span><span class="mi">8</span><span class="w"> </span><span class="mi">9</span><span class="w"> </span><span class="mi">10</span><span class="p">)</span><span class="w">
</span><span class="c1">;; cons in a list specific function, conj is a general purpose one and</span><span class="w">
</span><span class="c1">;; works on all collection (but in a different manner)</span><span class="w">
</span><span class="n">user&gt;</span><span class="w"> </span><span class="p">(</span><span class="nb">conj</span><span class="w"> </span><span class="n">a-list</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w">
</span><span class="p">(</span><span class="nf">0</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="mi">6</span><span class="w"> </span><span class="mi">7</span><span class="w"> </span><span class="mi">8</span><span class="w"> </span><span class="mi">9</span><span class="w"> </span><span class="mi">10</span><span class="p">)</span><span class="w">
</span><span class="c1">;; retrieve the first five items in a list</span><span class="w">
</span><span class="n">user&gt;</span><span class="w"> </span><span class="p">(</span><span class="nb">take</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="n">a-list</span><span class="p">)</span><span class="w">
</span><span class="p">(</span><span class="nf">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="mi">5</span><span class="p">)</span><span class="w">
</span><span class="c1">;; retrieve all but the first five items in a list</span><span class="w">
</span><span class="n">user&gt;</span><span class="w"> </span><span class="p">(</span><span class="nb">drop</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="n">a-list</span><span class="p">)</span><span class="w">
</span><span class="p">(</span><span class="nf">6</span><span class="w"> </span><span class="mi">7</span><span class="w"> </span><span class="mi">8</span><span class="w"> </span><span class="mi">9</span><span class="w"> </span><span class="mi">10</span><span class="p">)</span><span class="w">
</span><span class="n">user&gt;</span><span class="w"> </span><span class="p">(</span><span class="nb">take-while</span><span class="w"> </span><span class="o">#</span><span class="p">(</span><span class="nb">&lt;</span><span class="w"> </span><span class="n">%</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span><span class="w"> </span><span class="n">a-list</span><span class="p">)</span><span class="w">
</span><span class="p">(</span><span class="nf">1</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w">
</span><span class="n">user&gt;</span><span class="w"> </span><span class="p">(</span><span class="nb">drop-while</span><span class="w"> </span><span class="o">#</span><span class="p">(</span><span class="nb">&gt;</span><span class="w"> </span><span class="n">%</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span><span class="w"> </span><span class="n">a-list</span><span class="p">)</span><span class="w">
</span><span class="p">(</span><span class="nf">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="mi">6</span><span class="w"> </span><span class="mi">7</span><span class="w"> </span><span class="mi">8</span><span class="w"> </span><span class="mi">9</span><span class="w"> </span><span class="mi">10</span><span class="p">)</span><span class="w">
</span><span class="n">user&gt;</span><span class="w"> </span><span class="p">(</span><span class="nb">drop-while</span><span class="w"> </span><span class="o">#</span><span class="p">(</span><span class="nb">&lt;</span><span class="w"> </span><span class="n">%</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span><span class="w"> </span><span class="n">a-list</span><span class="p">)</span><span class="w">
</span><span class="p">(</span><span class="nf">3</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="mi">6</span><span class="w"> </span><span class="mi">7</span><span class="w"> </span><span class="mi">8</span><span class="w"> </span><span class="mi">9</span><span class="w"> </span><span class="mi">10</span><span class="p">)</span><span class="w">

</span><span class="c1">;;; Sets</span><span class="w">

</span><span class="n">user&gt;</span><span class="w"> </span><span class="p">(</span><span class="nb">set</span><span class="w"> </span><span class="o">'</span><span class="p">(</span><span class="nf">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">4</span><span class="p">))</span><span class="w">
</span><span class="o">#</span><span class="p">{</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="mi">5</span><span class="p">}</span><span class="w">
</span><span class="n">user&gt;</span><span class="w"> </span><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">a-set</span><span class="w"> </span><span class="o">#</span><span class="p">{</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="mi">5</span><span class="p">})</span><span class="w">
</span><span class="o">#</span><span class="ss">'user/a-set</span><span class="w">
</span><span class="n">user&gt;</span><span class="w"> </span><span class="p">(</span><span class="nb">contains?</span><span class="w"> </span><span class="n">a-set</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span><span class="w">
</span><span class="n">true</span><span class="w">
</span><span class="n">user&gt;</span><span class="w"> </span><span class="p">(</span><span class="nb">contains?</span><span class="w"> </span><span class="n">a-set</span><span class="w"> </span><span class="mi">7</span><span class="p">)</span><span class="w">
</span><span class="n">false</span><span class="w">
</span><span class="n">user&gt;</span><span class="w"> </span><span class="p">(</span><span class="nb">conj</span><span class="w"> </span><span class="n">a-set</span><span class="w"> </span><span class="mi">5</span><span class="p">)</span><span class="w">
</span><span class="o">#</span><span class="p">{</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="mi">5</span><span class="p">}</span><span class="w">
</span><span class="n">user&gt;</span><span class="w"> </span><span class="p">(</span><span class="nb">conj</span><span class="w"> </span><span class="n">a-set</span><span class="w"> </span><span class="mi">6</span><span class="p">)</span><span class="w">
</span><span class="o">#</span><span class="p">{</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="mi">6</span><span class="p">}</span><span class="w">
</span><span class="n">user&gt;</span><span class="w"> </span><span class="p">(</span><span class="nb">disj</span><span class="w"> </span><span class="n">a-set</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w">
</span><span class="o">#</span><span class="p">{</span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="mi">5</span><span class="p">}</span><span class="w">
</span><span class="n">user&gt;</span><span class="w"> </span><span class="p">(</span><span class="nb">get</span><span class="w"> </span><span class="n">a-set</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w">
</span><span class="mi">1</span><span class="w">
</span><span class="n">user&gt;</span><span class="w"> </span><span class="p">(</span><span class="nb">get</span><span class="w"> </span><span class="n">a-set</span><span class="w"> </span><span class="mi">7</span><span class="p">)</span><span class="w">
</span><span class="n">nil</span><span class="w">
</span><span class="c1">;; most set functions live in the clojure.set namespace</span><span class="w">
</span><span class="n">user&gt;</span><span class="w"> </span><span class="p">(</span><span class="nf">use</span><span class="w"> </span><span class="ss">'clojure.set</span><span class="p">)</span><span class="w">
</span><span class="n">nil</span><span class="w">
</span><span class="n">user&gt;</span><span class="w"> </span><span class="p">(</span><span class="nb">difference</span><span class="w"> </span><span class="o">#</span><span class="p">{</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">}</span><span class="w"> </span><span class="o">#</span><span class="p">{</span><span class="mi">1</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">5</span><span class="p">})</span><span class="w">
</span><span class="o">#</span><span class="p">{</span><span class="mi">2</span><span class="p">}</span><span class="w">
</span><span class="n">user&gt;</span><span class="w"> </span><span class="p">(</span><span class="nb">intersection</span><span class="w"> </span><span class="o">#</span><span class="p">{</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">}</span><span class="w"> </span><span class="o">#</span><span class="p">{</span><span class="mi">1</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">5</span><span class="p">})</span><span class="w">
</span><span class="o">#</span><span class="p">{</span><span class="mi">1</span><span class="w"> </span><span class="mi">3</span><span class="p">}</span><span class="w">
</span><span class="n">user&gt;</span><span class="w"> </span><span class="p">(</span><span class="nb">union</span><span class="w"> </span><span class="o">#</span><span class="p">{</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">}</span><span class="w"> </span><span class="o">#</span><span class="p">{</span><span class="mi">1</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">5</span><span class="p">})</span><span class="w">
</span><span class="o">#</span><span class="p">{</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">5</span><span class="p">}</span><span class="w">

</span><span class="c1">;;; Maps</span><span class="w">
</span><span class="n">user&gt;</span><span class="w"> </span><span class="p">(</span><span class="nb">hash-map</span><span class="w"> </span><span class="no">:Bozhidar</span><span class="w"> </span><span class="no">:Batsov</span><span class="w"> </span><span class="no">:Bruce</span><span class="w"> </span><span class="no">:Wayne</span><span class="w"> </span><span class="no">:Selina</span><span class="w"> </span><span class="no">:Kyle</span><span class="p">)</span><span class="w">
</span><span class="p">{</span><span class="no">:Selina</span><span class="w"> </span><span class="no">:Kyle,</span><span class="w"> </span><span class="no">:Bozhidar</span><span class="w"> </span><span class="no">:Batsov,</span><span class="w"> </span><span class="no">:Bruce</span><span class="w"> </span><span class="no">:Wayne</span><span class="p">}</span><span class="w">
</span><span class="n">user&gt;</span><span class="w"> </span><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">a-map</span><span class="w"> </span><span class="p">{</span><span class="no">:Bozhidar</span><span class="w"> </span><span class="no">:Batsov,</span><span class="w"> </span><span class="no">:Bruce</span><span class="w"> </span><span class="no">:Wayne,</span><span class="w"> </span><span class="no">:Selina</span><span class="w"> </span><span class="no">:Kyle</span><span class="p">})</span><span class="w">
</span><span class="o">#</span><span class="ss">'user/a-map</span><span class="w">
</span><span class="n">user&gt;</span><span class="w"> </span><span class="n">a-map</span><span class="w">
</span><span class="p">{</span><span class="no">:Bozhidar</span><span class="w"> </span><span class="no">:Batsov,</span><span class="w"> </span><span class="no">:Bruce</span><span class="w"> </span><span class="no">:Wayne,</span><span class="w"> </span><span class="no">:Selina</span><span class="w"> </span><span class="no">:Kyle</span><span class="p">}</span><span class="w">
</span><span class="n">user&gt;</span><span class="w"> </span><span class="p">(</span><span class="nb">get</span><span class="w"> </span><span class="n">a-map</span><span class="w"> </span><span class="no">:Bozhidar</span><span class="p">)</span><span class="w">
</span><span class="no">:Batsov</span><span class="w">
</span><span class="n">user&gt;</span><span class="w"> </span><span class="p">(</span><span class="nb">contains?</span><span class="w"> </span><span class="n">a-map</span><span class="w"> </span><span class="no">:Bozhidar</span><span class="p">)</span><span class="w">
</span><span class="n">true</span><span class="w">
</span><span class="n">user&gt;</span><span class="w"> </span><span class="p">(</span><span class="nb">contains?</span><span class="w"> </span><span class="n">a-map</span><span class="w"> </span><span class="no">:Clark</span><span class="p">)</span><span class="w">
</span><span class="n">false</span><span class="w">
</span><span class="n">user&gt;</span><span class="w"> </span><span class="p">(</span><span class="no">:Bozhidar</span><span class="w"> </span><span class="n">a-map</span><span class="p">)</span><span class="w">
</span><span class="no">:Batsov</span><span class="w">
</span><span class="n">user&gt;</span><span class="w"> </span><span class="p">(</span><span class="nb">assoc</span><span class="w"> </span><span class="n">a-map</span><span class="w"> </span><span class="no">:Lois</span><span class="w"> </span><span class="no">:Lane</span><span class="p">)</span><span class="w">
</span><span class="p">{</span><span class="no">:Lois</span><span class="w"> </span><span class="no">:Lane,</span><span class="w"> </span><span class="no">:Bozhidar</span><span class="w"> </span><span class="no">:Batsov,</span><span class="w"> </span><span class="no">:Bruce</span><span class="w"> </span><span class="no">:Wayne,</span><span class="w"> </span><span class="no">:Selina</span><span class="w"> </span><span class="no">:Kyle</span><span class="p">}</span><span class="w">
</span><span class="n">user&gt;</span><span class="w"> </span><span class="p">(</span><span class="nb">keys</span><span class="w"> </span><span class="n">a-map</span><span class="p">)</span><span class="w">
</span><span class="p">(</span><span class="no">:Bozhidar</span><span class="w"> </span><span class="no">:Bruce</span><span class="w"> </span><span class="no">:Selina</span><span class="p">)</span><span class="w">
</span><span class="n">user&gt;</span><span class="w"> </span><span class="p">(</span><span class="nb">vals</span><span class="w"> </span><span class="n">a-map</span><span class="p">)</span><span class="w">
</span><span class="p">(</span><span class="no">:Batsov</span><span class="w"> </span><span class="no">:Wayne</span><span class="w"> </span><span class="no">:Kyle</span><span class="p">)</span><span class="w">
</span><span class="n">user&gt;</span><span class="w"> </span><span class="p">(</span><span class="nb">dissoc</span><span class="w"> </span><span class="n">a-map</span><span class="w"> </span><span class="no">:Bruce</span><span class="p">)</span><span class="w">
</span><span class="p">{</span><span class="no">:Bozhidar</span><span class="w"> </span><span class="no">:Batsov,</span><span class="w"> </span><span class="no">:Selina</span><span class="w"> </span><span class="no">:Kyle</span><span class="p">}</span><span class="w">
</span><span class="n">user&gt;</span><span class="w"> </span><span class="p">(</span><span class="nb">merge</span><span class="w"> </span><span class="n">a-map</span><span class="w"> </span><span class="p">{</span><span class="no">:Alia</span><span class="w"> </span><span class="no">:Atreides,</span><span class="w"> </span><span class="no">:Arya</span><span class="w"> </span><span class="no">:Stark</span><span class="p">})</span><span class="w">
</span><span class="p">{</span><span class="no">:Arya</span><span class="w"> </span><span class="no">:Stark,</span><span class="w"> </span><span class="no">:Alia</span><span class="w"> </span><span class="no">:Atreides,</span><span class="w"> </span><span class="no">:Bozhidar</span><span class="w"> </span><span class="no">:Batsov,</span><span class="w"> </span><span class="no">:Bruce</span><span class="w"> </span><span class="no">:Wayne,</span><span class="w"> </span><span class="no">:Selina</span><span class="w"> </span><span class="no">:Kyle</span><span class="p">}</span><span class="w">

</span><span class="c1">;;; Vectors</span><span class="w">

</span><span class="n">user&gt;</span><span class="w"> </span><span class="p">(</span><span class="nb">vector</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">4</span><span class="p">)</span><span class="w">
</span><span class="p">[</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">4</span><span class="p">]</span><span class="w">
</span><span class="n">user&gt;</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">4</span><span class="p">]</span><span class="w">
</span><span class="p">[</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">4</span><span class="p">]</span><span class="w">
</span><span class="n">user&gt;</span><span class="w"> </span><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">a-vector</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="mi">5</span><span class="p">])</span><span class="w">
</span><span class="o">#</span><span class="ss">'user/a-vector</span><span class="w">
</span><span class="n">user&gt;</span><span class="w"> </span><span class="p">(</span><span class="nb">count</span><span class="w"> </span><span class="n">a-vector</span><span class="p">)</span><span class="w">
</span><span class="mi">5</span><span class="w">
</span><span class="n">user&gt;</span><span class="w"> </span><span class="p">(</span><span class="nb">conj</span><span class="w"> </span><span class="n">a-vector</span><span class="w"> </span><span class="mi">13</span><span class="p">)</span><span class="w">
</span><span class="p">[</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="mi">13</span><span class="p">]</span><span class="w">
</span><span class="c1">;; random access is a constant time operation in vectors</span><span class="w">
</span><span class="n">user&gt;</span><span class="w"> </span><span class="p">(</span><span class="nb">nth</span><span class="w"> </span><span class="n">a-vector</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span><span class="w">
</span><span class="mi">4</span><span class="w">
</span><span class="n">user&gt;</span><span class="w"> </span><span class="p">(</span><span class="nb">pop</span><span class="w"> </span><span class="n">a-vector</span><span class="p">)</span><span class="w">
</span><span class="p">[</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">4</span><span class="p">]</span><span class="w">
</span><span class="n">user&gt;</span><span class="w"> </span><span class="p">(</span><span class="nb">peek</span><span class="w"> </span><span class="n">a-vector</span><span class="p">)</span><span class="w">
</span><span class="mi">5</span><span class="w">
</span></code></pre></div></div>

<p>Most data structures in Clojure are part of a common Sequence API,
that we‚Äôll briefly discuss shortly.</p>

<h2 id="the-seq-api">The Seq API</h2>

<p>Clojure defines many algorithms in terms of sequences (seqs). A seq is
a logical list, and unlike most Lisps where the list is represented by
a concrete, 2-slot structure, Clojure uses the ISeq interface to allow
many data structures to provide access to their elements as
sequences. The <strong>seq</strong> function yields an implementation of ISeq
appropriate to the collection. Seqs differ from iterators in that they
are persistent and immutable, not stateful cursors into a
collection. As such, they are useful for much more than foreach -
functions can consume and produce seqs, they are thread safe, they can
share structure, etc.</p>

<p>Most of the sequence library functions are lazy, i.e. functions that
return seqs do so incrementally, as they are consumed, and thus
consume any seq arguments incrementally as well. Functions returning
lazy seqs can be implemented using the <strong>lazy-seq</strong> macro. The laziness
allows us to deal with infinite data structures easily (as long as we
don‚Äôt try to act on all of their elements that is):</p>

<figure class="highlight"><pre><code class="language-clojure" data-lang="clojure"><span class="n">user&gt;</span><span class="w"> </span><span class="p">(</span><span class="nb">take</span><span class="w"> </span><span class="mi">10</span><span class="w"> </span><span class="p">(</span><span class="nb">filter</span><span class="w"> </span><span class="n">even?</span><span class="w"> </span><span class="p">(</span><span class="nb">iterate</span><span class="w"> </span><span class="nb">inc</span><span class="w"> </span><span class="mi">1</span><span class="p">)))</span><span class="w">
</span><span class="p">(</span><span class="nf">2</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="mi">6</span><span class="w"> </span><span class="mi">8</span><span class="w"> </span><span class="mi">10</span><span class="w"> </span><span class="mi">12</span><span class="w"> </span><span class="mi">14</span><span class="w"> </span><span class="mi">16</span><span class="w"> </span><span class="mi">18</span><span class="w"> </span><span class="mi">20</span><span class="p">)</span></code></pre></figure>

<p><strong>iterate</strong> returns an infinite lazy sequence. <strong>filter</strong> returns a lazy
sequence as well. With <strong>take</strong> we can take only the elements we need
without have to process the entire infinite collection.</p>

<h2 id="functional-programing-with-clojure">Functional programing with Clojure</h2>

<p>Clojure is a functional programming language and as such it offers quite
the selection of features that make it easy to leverage the functional
programming techniques.</p>

<ul>
  <li>functions are objects</li>
  <li>all built-in data structures are immutable</li>
  <li>most functions in the core library are pure (they don‚Äôt produce any
side results and they don‚Äôt interact with the outside world in any
manner other than just receiving their parameters from it)</li>
  <li>there are no iteration constructs like <strong>for</strong> and <strong>while</strong> in
other languages. In place of iteration list comprehensions and
recursion are commonly used.</li>
  <li>everything is an expression that yields some result - even things
that are traditionally statements in other languages such as <strong>if</strong> and
<strong>print</strong> (although the return value of print is not particularly useful)</li>
</ul>

<h2 id="parallel-programming">Parallel programming</h2>

<p>Functional programming and parallel programming complement each
other. When most of your code is contained in pure functions it‚Äôs
naturally tread safe (not to mention much easier to test). Since you
don‚Äôt have any mutable state there, it‚Äôs absolutely safe to fire those
pure functions in as many threads as you wish and you‚Äôll have
absolutely nothing to worry about.</p>

<p>Programs, however, eventually produce side effects and often they
really have to have some mutable state. Clojure makes it easy to model
such situations in your programs in a way that doesn‚Äôt compromise the
ability to parallelize the programs.</p>

<h4 id="refs-and-transactions">Refs and transactions</h4>

<p>Transactional references (known as refs in Clojure) ensure safe shared use of mutable
storage locations via a software transactional memory (STM)
system. Refs are bound to a single storage location for their
lifetime, and only allow mutation of that location to occur within a
transaction.</p>

<p>Clojure transactions should be easy to understand if you‚Äôve ever used
database transactions - they ensure that all actions on refs are
atomic, consistent, and isolated. Atomic means that every change to
refs made within a transaction occurs or none do. Consistent means
that each new value can be checked with a validator function before
allowing the transaction to commit. Isolated means that no transaction
sees the effects of any other transaction while it is running. Another
feature common to STMs is that, should a transaction have a conflict
while running, it is automatically retried.</p>

<p>There are many ways to do STMs (locking/pessimistic,
lock-free/optimistic and hybrids) and it is still a research
problem. The Clojure STM uses multiversion concurrency control with
adaptive history queues for snapshot isolation, and provides a
distinct commute operation. Here‚Äôs a short example:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">picked-numbers</span><span class="w"> </span><span class="p">(</span><span class="nb">ref</span><span class="w"> </span><span class="o">#</span><span class="p">{})</span><span class="w">

</span><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">secret-num</span><span class="w"> </span><span class="p">(</span><span class="nf">.nextInt</span><span class="w"> </span><span class="p">(</span><span class="nf">java.util.Random.</span><span class="p">)</span><span class="w"> </span><span class="mi">10</span><span class="p">))</span><span class="w">

</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">guess-number</span><span class="w"> </span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="w">
        </span><span class="p">(</span><span class="nb">print</span><span class="w"> </span><span class="s">"Enter a guess between 1 and 10: "</span><span class="p">)</span><span class="w">
        </span><span class="p">(</span><span class="nb">flush</span><span class="p">)</span><span class="w">
        </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">guess</span><span class="w"> </span><span class="p">(</span><span class="nf">java.lang.Integer/parseInt</span><span class="w"> </span><span class="p">(</span><span class="nb">read-line</span><span class="p">))</span><span class="w"> </span><span class="p">]</span><span class="w">
             </span><span class="p">(</span><span class="k">cond</span><span class="w">
               </span><span class="p">(</span><span class="nb">=</span><span class="w"> </span><span class="n">guess</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">println</span><span class="w"> </span><span class="s">"You guessed correctly"</span><span class="p">)</span><span class="w">
               </span><span class="p">(</span><span class="nb">contains?</span><span class="w"> </span><span class="p">(</span><span class="nb">deref</span><span class="w"> </span><span class="n">picked-numbers</span><span class="p">)</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">println</span><span class="w"> </span><span class="s">"Pick another number! You already tried that one."</span><span class="p">)</span><span class="w">
               </span><span class="no">:else</span><span class="w"> </span><span class="p">(</span><span class="nb">dosync</span><span class="w">
                      </span><span class="p">(</span><span class="nb">alter</span><span class="w"> </span><span class="n">picked-numbers</span><span class="w"> </span><span class="nb">conj</span><span class="w"> </span><span class="n">guess</span><span class="p">)))))</span><span class="w">

</span><span class="n">user=&gt;</span><span class="w"> </span><span class="p">(</span><span class="nf">guess-number</span><span class="w"> </span><span class="n">secret-num</span><span class="p">)</span><span class="w">
</span><span class="n">Enter</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">guess</span><span class="w"> </span><span class="n">between</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="nb">and</span><span class="w"> </span><span class="mi">10</span><span class="err">:</span><span class="w"> </span><span class="mi">1</span><span class="w">
</span><span class="o">#</span><span class="p">{</span><span class="mi">1</span><span class="p">}</span><span class="w">
</span><span class="n">user=&gt;</span><span class="w"> </span><span class="p">(</span><span class="nf">guess-number</span><span class="w"> </span><span class="n">secret-num</span><span class="p">)</span><span class="w">
</span><span class="n">Enter</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">guess</span><span class="w"> </span><span class="n">between</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="nb">and</span><span class="w"> </span><span class="mi">10</span><span class="err">:</span><span class="w"> </span><span class="mi">3</span><span class="w">
</span><span class="o">#</span><span class="p">{</span><span class="mi">1</span><span class="w"> </span><span class="mi">3</span><span class="p">}</span><span class="w">
</span><span class="n">user=&gt;</span><span class="w"> </span><span class="p">(</span><span class="nf">guess-number</span><span class="w"> </span><span class="n">secret-num</span><span class="p">)</span><span class="w">
</span><span class="n">Enter</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">guess</span><span class="w"> </span><span class="n">between</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="nb">and</span><span class="w"> </span><span class="mi">10</span><span class="err">:</span><span class="w"> </span><span class="mi">5</span><span class="w">
</span><span class="o">#</span><span class="p">{</span><span class="mi">1</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">5</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<p>I hope you got the basic idea from this simple, but mostly useless
snippet. Generally when we have only one object that we‚Äôll be changing
in this manner an atom is a more appropriate choice as we‚Äôll see shortly.</p>

<h4 id="agents">Agents</h4>

<p>Like <em>refs</em>, <em>agents</em> provide shared access to mutable state. Where refs
support coordinated, synchronous change of multiple locations, agents
provide independent, asynchronous change of individual
locations (to put it into simpler term you‚Äôd use refs if you had to
updated several things and wait for the update to happen and agents if
you need to update only one thing and don‚Äôt really care when the
update will happen - only that it will happen). Agents are bound to a single storage location for their
lifetime, and only allow mutation of that location (to a new state) to
occur as a result of an action. Actions are functions (with,
optionally, additional arguments) that are asynchronously applied to
an agent‚Äôs state and whose return value becomes the agent‚Äôs new
state. Let‚Äôs see an agent (Smith maybe?) in action:</p>

<figure class="highlight"><pre><code class="language-clojure" data-lang="clojure"><span class="n">user&gt;</span><span class="w"> </span><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">some-agent</span><span class="w"> </span><span class="p">(</span><span class="nb">agent</span><span class="w"> </span><span class="mi">0</span><span class="p">))</span><span class="w">
</span><span class="o">#</span><span class="ss">'user/some-agent</span><span class="w">
</span><span class="n">user&gt;</span><span class="w"> </span><span class="p">(</span><span class="nb">dotimes</span><span class="w"> </span><span class="p">[</span><span class="n">i</span><span class="w"> </span><span class="mi">100</span><span class="p">]</span><span class="w">
               </span><span class="p">(</span><span class="nb">send</span><span class="w"> </span><span class="n">some-agent</span><span class="w"> </span><span class="nb">inc</span><span class="p">))</span><span class="w">
</span><span class="n">nil</span><span class="w">
</span><span class="n">user&gt;</span><span class="w"> </span><span class="n">some-agent</span><span class="w">
</span><span class="o">#</span><span class="n">&lt;Agent</span><span class="o">@</span><span class="mi">15</span><span class="n">c024c</span><span class="err">:</span><span class="w"> </span><span class="mi">100</span><span class="nb">&gt;</span><span class="w">
</span><span class="n">user&gt;</span><span class="w"> </span><span class="o">@</span><span class="n">some-agent</span><span class="w">
</span><span class="mi">100</span></code></pre></figure>

<h4 id="atoms">Atoms</h4>

<p>Atoms provide a way to manage shared, synchronous, independent
state. They are a reference type like refs and vars. You create an
atom with atom, and can access its state with deref (or @). Let‚Äôs
rework the refs example to use an atom:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">picked-numbers</span><span class="w"> </span><span class="p">(</span><span class="nf">atom</span><span class="w"> </span><span class="o">#</span><span class="p">{})</span><span class="w">

</span><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">secret-num</span><span class="w"> </span><span class="p">(</span><span class="nf">.nextInt</span><span class="w"> </span><span class="p">(</span><span class="nf">java.util.Random.</span><span class="p">)</span><span class="w"> </span><span class="mi">10</span><span class="p">))</span><span class="w">

</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">guess-number</span><span class="w"> </span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="w">
        </span><span class="p">(</span><span class="nb">print</span><span class="w"> </span><span class="s">"Enter a guess between 1 and 10: "</span><span class="p">)</span><span class="w">
        </span><span class="p">(</span><span class="nb">flush</span><span class="p">)</span><span class="w">
        </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">guess</span><span class="w"> </span><span class="p">(</span><span class="nf">java.lang.Integer/parseInt</span><span class="w"> </span><span class="p">(</span><span class="nb">read-line</span><span class="p">))</span><span class="w"> </span><span class="p">]</span><span class="w">
             </span><span class="p">(</span><span class="k">cond</span><span class="w">
               </span><span class="p">(</span><span class="nb">=</span><span class="w"> </span><span class="n">guess</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">println</span><span class="w"> </span><span class="s">"You guessed correctly"</span><span class="p">)</span><span class="w">
               </span><span class="p">(</span><span class="nb">contains?</span><span class="w"> </span><span class="p">(</span><span class="nb">deref</span><span class="w"> </span><span class="n">picked-numbers</span><span class="p">)</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">println</span><span class="w"> </span><span class="s">"Pick another number! You already tried that one."</span><span class="p">)</span><span class="w">
               </span><span class="no">:else</span><span class="w"> </span><span class="p">(</span><span class="nf">swap!</span><span class="w"> </span><span class="n">picked-numbers</span><span class="w"> </span><span class="nb">conj</span><span class="w"> </span><span class="n">guess</span><span class="p">))))</span><span class="w">

</span><span class="n">user=&gt;</span><span class="w"> </span><span class="p">(</span><span class="nf">guess-number</span><span class="w"> </span><span class="n">secret-num</span><span class="p">)</span><span class="w">
</span><span class="n">Enter</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">guess</span><span class="w"> </span><span class="n">between</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="nb">and</span><span class="w"> </span><span class="mi">10</span><span class="err">:</span><span class="w"> </span><span class="mi">1</span><span class="w">
</span><span class="o">#</span><span class="p">{</span><span class="mi">1</span><span class="p">}</span><span class="w">
</span><span class="n">user=&gt;</span><span class="w"> </span><span class="p">(</span><span class="nf">guess-number</span><span class="w"> </span><span class="n">secret-num</span><span class="p">)</span><span class="w">
</span><span class="n">Enter</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">guess</span><span class="w"> </span><span class="n">between</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="nb">and</span><span class="w"> </span><span class="mi">10</span><span class="err">:</span><span class="w"> </span><span class="mi">3</span><span class="w">
</span><span class="o">#</span><span class="p">{</span><span class="mi">1</span><span class="w"> </span><span class="mi">3</span><span class="p">}</span><span class="w">
</span><span class="n">user=&gt;</span><span class="w"> </span><span class="p">(</span><span class="nf">guess-number</span><span class="w"> </span><span class="n">secret-num</span><span class="p">)</span><span class="w">
</span><span class="n">Enter</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">guess</span><span class="w"> </span><span class="n">between</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="nb">and</span><span class="w"> </span><span class="mi">10</span><span class="err">:</span><span class="w"> </span><span class="mi">5</span><span class="w">
</span><span class="o">#</span><span class="p">{</span><span class="mi">1</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">5</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<h4 id="vars">Vars</h4>

<p>Bindings created with the <strong>binding</strong> macro cannot be seen by any other
thread. Bindings created with binding can be assigned to, which
provides a means for a nested context to communicate with code before
it on the call stack.</p>

<p>I‚Äôll not be discussing them further, because Vars are a vast subject
deserving its own post.</p>

<h2 id="oop-lisp-style">OOP, Lisp style</h2>

<p>Object oriented programming in most programming languages is based on
a single dispatch message passing. The object on which we invoke a
method (poor choice of words, but easier to comprehend) is the
receiver, the method name and it‚Äôs arguments are the message. The
method‚Äôs invoked solely on the base of the type of the receiver
object.</p>

<p>Lisps have traditionally implemented OOP with generic methods, that
don‚Äôt have a receiver and are dispatched on the basis of the types of
all of their arguments. In the world of multiple dispatch the more
traditional single dispatch is just a special case in which only the
type of the first method argument matters. Here‚Äôs a taste of
multimethods in Clojure:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defmulti</span><span class="w"> </span><span class="n">my-add</span><span class="w"> </span><span class="p">(</span><span class="k">fn</span><span class="w"> </span><span class="p">[</span><span class="n">x</span><span class="w"> </span><span class="n">y</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="nb">and</span><span class="w"> </span><span class="p">(</span><span class="nb">string?</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">string?</span><span class="w"> </span><span class="n">y</span><span class="p">))))</span><span class="w">

</span><span class="p">(</span><span class="k">defmethod</span><span class="w"> </span><span class="n">my-add</span><span class="w"> </span><span class="n">true</span><span class="w"> </span><span class="p">[</span><span class="n">x</span><span class="w"> </span><span class="n">y</span><span class="p">]</span><span class="w">
    </span><span class="p">(</span><span class="nb">str</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">y</span><span class="p">))</span><span class="w">

</span><span class="p">(</span><span class="k">defmethod</span><span class="w"> </span><span class="n">my-add</span><span class="w"> </span><span class="n">false</span><span class="w"> </span><span class="p">[</span><span class="n">x</span><span class="w"> </span><span class="n">y</span><span class="p">]</span><span class="w">
    </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">y</span><span class="p">))</span><span class="w">

</span><span class="n">user=&gt;</span><span class="w"> </span><span class="p">(</span><span class="nf">my-add</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">4</span><span class="p">)</span><span class="w"> </span><span class="c1">; =&gt; 7</span><span class="w">
</span><span class="n">user=&gt;</span><span class="w"> </span><span class="p">(</span><span class="nf">my-add</span><span class="w"> </span><span class="s">"3"</span><span class="w"> </span><span class="s">"4"</span><span class="p">)</span><span class="w"> </span><span class="c1">; =&gt; "34"</span><span class="w">
</span></code></pre></div></div>

<p>Here we defined a multi-method that behaves differently for string and
numeric arguments - strings args are concatenated and numeric args are
added together.</p>

<h2 id="interactive-development">Interactive development</h2>

<p>Traditional programming languages have more or less the following work
flow:</p>

<ul>
  <li>write the unit tests (power to TDD)</li>
  <li>write the source file</li>
  <li>compile the source file (if needed)</li>
  <li>run the source file with an interpreter or run the binary file that
resulted from the compilation step</li>
  <li>if you need to modify something you edit the code and repeat the
other steps</li>
</ul>

<p>Those programs naturally have some entry points. Alternative you can
simple use the test suite you‚Äôve initially developed.</p>

<p>A Lisp developers generally has a very different work flow:</p>

<ul>
  <li>start a REPL</li>
  <li>write some unit tests</li>
  <li>write a few functions definitions in a source file</li>
  <li>compile them interactively and load them in a REPL</li>
  <li>test these functions directly from the REPL</li>
  <li>if you need to modify a function - just edit it and reload in the
REPL</li>
</ul>

<p>I‚Äôve been a C/C++ and Java developer for a long time and I didn‚Äôt see
anything wrong with first model. In fact - I had been practising it
for so very long that it felt quite natural to me. After I‚Äôve started
hacking with Lisp, however, my old work flow started to feel very
unproductive to me (especially with statically typed languages). Here
are some key aspects of the interactive (and iterative) development
that is so common in Lisp (not only in Common Lisp):</p>

<ul>
  <li>The REPL is an integral process of the coding process. Ruby and
Python developers generally tend to use it only for exploratory
programming although many of the techniques common for Lisp could be
applied for Ruby and Python as well.</li>
  <li>Functions can be defined (and redefined) in real time</li>
  <li>Loading &amp; compilation of code at runtime</li>
  <li>Powerful introspection features</li>
  <li>Interactive development</li>
  <li>Iterative development - you know the old saying ‚ÄúLather, rinse,
repeat‚Ä¶‚Äù (probably one of the oldest examples of recursion).</li>
</ul>

<h2 id="the-tools-of-the-trade">The tools of the trade</h2>

<p>The single biggest problem with Clojure in the moment (at least in my
opinion) has nothing to do with the language itself. The problem is
the lack of decent tooling and infrastructure around it. Lisp hackers
have traditionally favoured the SLIME development environment for
Emacs. Unfortunately the maintainers are not especially interested in
having Clojure support (since SLIME targets Common Lisp) and nobody in
Clojure community seems to be capable of writing an adequate swank
component for Clojure that can be used with an up-to-date version of
SLIME. The existing one is quite rudimentary and doesn‚Äôt work with
stock SLIME distributions. But this is not the worst part - the worst
part is that even this crippled SLIME is still the best development
tool for Clojure. IntelliJ‚Äôs plug-in is almost unusable, Eclipse‚Äôs is
barely usable and NetBeans‚Äôs cannot be installed half the time‚Ä¶</p>

<ul>
  <li>IDEs
    <ul>
      <li><a href="http://plugins.intellij.net/plugin/?id=4050">IntelliJ IDEA</a> -
everyone knows how much I love IntelliJ IDEA. Sadly I cannot say
a good word about the La Clojure plug-in. Its mostly unmaintained
(and often broken), has pretty limited features and is generally
good for‚Ä¶ nothing. It‚Äôs sad to see it‚Äôs so far back in
JetBrains‚Äôs priority list - they are doing wonderful things in
their Groovy and Scala plugins.</li>
      <li><a href="http://code.google.com/p/counterclockwise/">Eclipse</a> - Eclipse
certainly boasts the best IDE Clojure plug-in at the moment (Counter
clock-wise). It has a lot of features found otherwise only in
SLIME. It even features partial paredit support. Being the best
in such a sorry bunch is not quite an achievement, but at least
the guys there are trying really hard and I‚Äôm sure that within one
or two releases they‚Äôll have a great product.</li>
      <li><a href="http://www.enclojure.org/">NetBeans</a> - The Enclojure plug-in
seems to be abandoned currently. It has no released a new version
in over an year and the old one were buggy as hell (when they the
decency to get themselves installed, that is).</li>
      <li><a href="https://github.com/technomancy/swank-clojure">SLIME</a> - The Ultimate Clojure programming environment. Even though
it‚Äôs lacking a few features of the Common Lisp counterpart, SLIME
still is the best option for Clojure development, uniquely
attuned to the Lisp philosophy of interactive and incremental development.</li>
    </ul>
  </li>
</ul>

<p>Luckily there‚Äôs no lack of good build tools that one can use with Clojure.</p>

<ul>
  <li>Build tools
    <ul>
      <li><a href="http://maven.Apache.org">Apache Maven</a> - Maven has a nice
Clojure plugin</li>
      <li><a href="https://github.com/technomancy/leiningen">Leiningen</a> - probably
the most popular Clojure-specific build tool</li>
      <li><a href="https://github.com/ninjudd/cake">Cake</a> - a solid alternative to Leiningen</li>
      <li><a href="http://www.gradle.org/">Gradle</a> - a build system for Java-based
applications, written in Groovy, that supports Clojure</li>
      <li><a href="http://buildr.apache.org/">Apache Builder</a> - a build system for
Java-based applications, written in Ruby , that supports Clojure</li>
    </ul>
  </li>
</ul>

<h2 id="resources">Resources</h2>

<ul>
  <li>Books
    <ul>
      <li><a href="http://pragprog.com/titles/shcloj/programming-clojure">‚ÄúProgramming Clojure‚Äù</a></li>
      <li><a href="http://www.apress.com/9781430272311">‚ÄúPractical Clojure‚Äù</a></li>
      <li><a href="http://joyofclojure.com/">‚ÄúThe Joy of Clojure‚Äù</a></li>
    </ul>
  </li>
  <li>Screencasts &amp; Video lectures
    <ul>
      <li><a href="http://clojure.blip.tv/">‚ÄúClojure‚Äôs channel‚Äù</a></li>
    </ul>
  </li>
  <li>Websites &amp; Blogs
    <ul>
      <li><a href="http://blog.fogus.me/">Official website</a></li>
      <li><a href="http://disclojure.org/">Disclojure</a> - a clojure news aggregator</li>
    </ul>
  </li>
  <li>Exercises
    <ul>
      <li><a href="/blog/2011/05/04/lisp-problems/">Lisp problems</a> - a work in progress, I‚Äôll add Clojure
solutions next to the Common Lisp ones when I have some thime</li>
      <li><a href="http://foognostic.net/labrepl-summary/">Labrepl</a></li>
      <li><a href="http://projecteuler.net/">Project Euler</a></li>
      <li><a href="https://github.com/functional-koans/clojure-koans">Clojure Koans</a></li>
    </ul>
  </li>
</ul>

<h2 id="epilogue">Epilogue</h2>

<p>Clojure is a radical departure from both traditional Algol-derived
languages and existing Lisp dialects. Its advanced support for
functional programming, combined with a state of the art concurrency
support make it attractive language for the development of heavy duty
enterprise grade systems. Coupled with the seamless Java integration
the sky seems to be the limit for Clojure‚Ä¶</p>

<p>Unfortunately Clojure has to face several problems if it‚Äôs to
succeed. First of all it has to attract a critical mass of developers
that are not afraid of the syntactic difference with common
languages. Then there is the concept of functional thinking - a way of
thinking quite foreign to most developers. To be able to properly
leverage the full power of Clojure developers have to be ready to
overcome a steep learning curve, but rest assured, the prize at the
end of the journey is well worth it.</p>

<p>Another gripe with Clojure at this point is the lack of decent
tooling. Sure, we have the <em>supported</em> SLIME, available in ELPA, but
even Emacs users are not particularly happy with it. And let‚Äôs face
reality - it‚Äôs quite unlikely that many developers will be willing to
give up the comfort of their beloved IDEs just to be able to code in
Clojure. Eclipse, IntelliJ &amp; NetBeans are unfortunately nowhere near
providing a good Clojure experience. Hopefully, this will change
soon‚Ä¶</p>

<p>I‚Äôm a very big fan of Lisp in general, that is no secret. I‚Äôve tried
to be as objective as possible and abstained myself from over
extolling some of Clojure‚Äôs virtues. I‚Äôd like to say, however, that
I‚Äôm very excited that we finally have a Lisp dialect that is modern,
simple, powerful, elegant and most of all - capable of getting the job
done. I really hope that Clojure will be instrument of Lisp return on
the centre stage of programming, where it deserves to be.</p>

<p>As usual the article is very shallow overview and doesn‚Äôt even
mention some important features of the language. Be sure to check out
some of the resources mentioned.</p>

<p><em>P.S. This is the last of the articles that I‚Äôd originally intended to
write. I‚Äôm considering the possibility to write a couple of more
chapter of the Java.next() series if people are interested to read
them. JRuby will probably make an appearance, but I‚Äôd like to hear
some reader input as well. So, what JVM language do you think is
worthy enough to make an appearance in the Java.next() series?</em></p>
:ET