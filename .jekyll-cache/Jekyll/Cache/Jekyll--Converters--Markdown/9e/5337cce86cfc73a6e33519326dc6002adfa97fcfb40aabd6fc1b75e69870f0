I".X<h2 id="prelude">Prelude</h2>

<p>So far in the Java.next() series I’ve discussed only languages that
were engineered from the start to run on the JVM (<a href="/Java/Groovy/2011/05/06/jvm-langs-groovy.html">Groovy</a>, <a href="/Java/Scala/2011/05/08/jvm-langs-scala.html">Scala</a> and
<a href="/Clojure/Java/2011/05/12/jvm-langs-clojure.html">Clojure</a>). However, a lot of good programming languages existed even
before the inception of the idea to run languages other than Java on top of
the JVM. Some notable examples are Ruby and Python for instance. Today
I’ll be writing about <a href="http://jruby.org/">JRuby</a> - the pure Java port of the Ruby
programming language (and undoubtedly the most advanced and widely
adopted of the 9 (!) actively maintained Ruby ports).</p>

<p>This post will differ somewhat from the others so far, because I won’t
be spending any time to dwell on the basic Ruby syntax and will only
highlight the advantages over plain old Ruby that JRuby provides -
like calling Java code from a Ruby application and scripting Ruby from a
Java application.</p>

<h2 id="why-jruby">Why JRuby?</h2>

<p>Ruby has long been known as one of the most elegant programming
languages out there. With the rise of the Rails web framework several
years ago the language was propelled into the mainstream and showed a
lot of common developers alternative (better) ways to get their jobs done with
less hassle and more grace. While the language is generally well liked
(albeit is has some syntax quirks and oddities, mostly courtesy of its
Perl heritage) its default execution environment MRI (Matz’s Ruby
Interpreter) is not the object of international affection. As an
application written in C it suffers some portability problems (a few
years ago it was quite hard to get MRI to run properly on Windows and
even now you might run into some missing dll error from time to
time). MRI’s performance is not stellar either and it even used to be
quite terrible before the advent of Ruby 1.9 which incorporated YARV
(Yet Another Ruby VM), which significantly improved its performance
(but still left a what to be desired). There is also the problem with
the missing standard portable GUI development library and the somewhat
limited deployment options because of MRI’s limited
portability.</p>

<p>Matz’s has often said that he’s no VM specialist, he’s a
language architect/designer and the beauty of the language concerns
him more than the performance of the reference implementation. He’s
also said that he loves diversity and is certain that interested
parties will offer high quality alternatives to the standard Ruby
runtime.</p>

<p>When it comes down to a high quality runtimes few people don’t start
thinking immediately about the Java platform, known for its infinite
(not literally infinite of course, but vast enough) libraries,
rock-solid and secure JVM and great support for compile-time and
runtime performance
optimizations. It’s not unheard for a Java application to match and
excel the performance of a native C application by employing
techniques like <em>just in time</em>(JIT) compilation, hot spot detection and
optimizations, etc.</p>

<p>So it’s only natural that at some point a bunch of people decided to
create a version of Ruby that could run on top of the acclaimed
JVM. This version of Ruby is (believe it or not) known as JRuby. With
JRuby you get the best of both Java and the Ruby worlds. Here are just a few possibilities:</p>

<ul>
  <li>Deploy a Ruby on Rails web application to Google’s App Engine
service.</li>
  <li>Write a Rails web frontend to your existing Java enterprise
application.</li>
  <li>Target the latest Android smartphones with your Ruby code using <a href="http://ruboto.org/">Ruboto</a></li>
  <li>Create cross-platform GUIs with Java’s Swing (or SWT)</li>
  <li>Build your project on solid libraries written in Java, Scala, Clojure,
or other JVM languages.</li>
  <li>Use the solid platform independent JDBC database
drivers. Platform dependent drivers used with MRI Ruby are a common
source of gripe for developers trying to migrate an application from
one platform to another.</li>
</ul>

<p>Great prospects indeed! Now it’s about time to get that magical piece
of software called JRuby up and running…</p>

<h2 id="installing-jruby">Installing JRuby</h2>

<p>There are several options to consider in the department of JRuby
installation. JRuby requires a Java runtime 5.0+ to be installed. You
can get one from <a href="http://www.oracle.com/technetwork/java/index.html">here</a>.</p>

<h4 id="using-an-installer">Using an Installer</h4>

<p>The easiest way to install JRuby is to use one of the prebuilt installers
available from the <a href="http://jruby.org/download">official download site</a>. These will take care of the
low level of detail, such as setting up your <strong>PATH</strong> environment
variable to make finding JRuby easier.
The JRuby team currently maintains installers for Windows and Mac
machines. If you’re on Linux, your distribution may package its own
JRuby build. For example, on Ubuntu (or any other Debian derived
distro) you can type this:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">sudo </span>apt-get <span class="nb">install </span>jruby
</code></pre></div></div>

<p>Red Had distribution users might try this incantation instead:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">sudo </span>yum <span class="nb">install </span>jruby
</code></pre></div></div>

<p>Most Linux distributions don’t upgrade to the latest JRuby release the
instant it comes out. If you want to stay with the latest and greatest,
you might prefer installing from an archive instead or RVM instead.</p>

<h4 id="using-rvm">Using RVM</h4>

<p>Most Ruby hackers
favour a powerful bash script called RVM(Ruby Version Manager) that
allows you to install several different version(or flavours of Ruby)
and switch easily between them. Please refer to the official
<a href="https://rvm.beginrescueend.com/">RVM documentation</a> for installation
and usage instructions. After you’ve installed RVM getting JRuby
installed is a child’s play:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>rvm list known | <span class="nb">grep </span>jruby
jruby-1.2.0
jruby-1.3.1
jruby-1.4.0
jruby-1.6.0
jruby[-1.6.1]
jruby-head

<span class="nv">$ </span>rvm <span class="nb">install </span>jruby
<span class="nv">$ </span>rvm use jruby
</code></pre></div></div>

<p>Just for the record - I personally use RVM and I recommend to all
*BSD, Linux &amp; OS X hackers to try it out as well - great piece of
software. One of the nicer side effects of using RVM is that you won’t
have to run operations like <strong>gem install</strong> as the root user.</p>

<h4 id="using-prebuilt-archive">Using prebuilt archive</h4>

<p>If you have a heavily customized setup or just like doing things
yourself, you can get a .zip or .tar.gz archive from the same download
page. Extract the archive somewhere convenient on your system, such
as <strong>C:** or **/opt</strong>. You can run JRuby straight from its own <em>bin</em>
folder, but you’ll probably find it more convenient to add it to
your PATH. On UNIX (including Linux &amp; Mac OS X), you can do the following:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">export </span><span class="nv">PATH</span><span class="o">=</span><span class="nv">$PATH</span>:/opt/jruby/bin
</code></pre></div></div>

<h4 id="testing-the-installation">Testing the installation</h4>

<p>Type the following commands:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>which jruby
~/.rvm/rubies/jruby-1.6.1/bin/jruby
<span class="nv">$ </span>jruby <span class="nt">-version</span>
jruby 1.6.1 <span class="o">(</span>ruby-1.8.7-p330<span class="o">)</span> <span class="o">(</span>2011-04-12 85838f6<span class="o">)</span> <span class="o">(</span>Java HotSpot<span class="o">(</span>TM<span class="o">)</span> Server VM 1.6.0_22<span class="o">)</span> <span class="o">[</span>linux-i386-java]
<span class="nv">$ </span>jruby <span class="nt">-e</span> <span class="s1">'puts "Hello, JRuby!"'</span>
Hello, JRuby!
</code></pre></div></div>

<p>Now we can see some of the unique JRuby features in action.</p>

<h2 id="common-tasks-with-jruby">Common tasks with JRuby</h2>

<p><strong>REPL</strong></p>

<p>JRuby comes with an equivalent of the standard Ruby REPL irb, called
jirb. To start it simply type:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>jirb
</code></pre></div></div>

<p>Now you can do some interactive Ruby development:</p>

<div class="language-irb highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="go">jruby-1.6.1 :001 &gt; puts "Hello, JRuby"
Hello, JRuby
 =&gt; nil
jruby-1.6.1 :002 &gt; arr = ["Chuck", "Sarah", "Morgan", "Casey"]
 =&gt; ["Chuck", "Sarah", "Morgan", "Casey"]
jruby-1.6.1 :003 &gt; arr.length
 =&gt; 4
jruby-1.6.1 :004 &gt; arr.size
 =&gt; 4
jruby-1.6.1 :005 &gt; arr.size()
 =&gt; 4
jruby-1.6.1 :006 &gt; arr.each { |name| puts name }
Chuck
Sarah
Morgan
Casey
 =&gt; ["Chuck", "Sarah", "Morgan", "Casey"]
jruby-1.6.1 :007 &gt; arr.each_with_index { |name, index| puts "##{index}: #{name}"}
0: Chuck
1: Sarah
2: Morgan
3: Casey
 =&gt; ["Chuck", "Sarah", "Morgan", "Casey"]
</span></code></pre></div></div>

<p>jirb is a great tool for exploratory programming and has some nice
features like TAB completion. Use it often!</p>

<h4 id="running-scripts">Running scripts</h4>

<p>Same as before (with MRI Ruby):</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>jruby some_script.rb
</code></pre></div></div>

<p>That was simple, right?</p>

<h4 id="running-ruby-tools">Running Ruby tools</h4>

<p>You should prefix calls to common Ruby tools like gem and rake with
<strong>jruby -S</strong> - otherwise they might get confused which Ruby version
(if you have more than one Ruby installed, that is) to use:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>jruby <span class="nt">-S</span> gem <span class="nb">install </span>rails
<span class="nv">$ </span>jruby <span class="nt">-S</span> rake <span class="nb">install</span>
</code></pre></div></div>

<h4 id="using-the-jruby-compiler">Using the JRuby compiler</h4>

<p>You can compile Ruby scripts directly to Java bytecode and run the
resulting class files using the JVM:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>jrubyc hello.rb
Compiling hello.rb to class example
</code></pre></div></div>

<p>The compiler supplies a main method for you, so you can now run the
program straight from the java command (adjust the path here to point
to your JRuby installation):</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>java <span class="nt">-cp</span> .:/opt/jruby/lib/hello.jar example
</code></pre></div></div>

<p>Note that your compiled program still depends on some JRuby-defined
support routines, so jruby.jar needs to be on your classpath. Also,
the compiler compiles only the files you specifically pass to it. If
you reference some_ruby_library.rb from hello.rb, you’ll have to
compile that extra .rb file yourself or ship it in source form
alongside your .class file. The Java compiler understands dependencies
between source files and compiles them automatically so Java
developers should keep this difference in mind.</p>

<h2 id="using-java-from-jruby">Using Java from JRuby</h2>

<p>One of the nicest features of JRuby is undoubtedly the ability to use
Java libraries directly in your Ruby code. JRuby goes a long way to
make the Java classes integrate into normal Ruby code as seamlessly as
possible - for instance it gives you the ability to call methods using the
snake_naming_convention, instead of the common in Java
camelCaseNamingConvention. Let’s see the Java integration in action:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">require</span> <span class="s1">'java'</span>
<span class="n">java_import</span> <span class="s1">'java.lang.System'</span>
<span class="n">java_import</span> <span class="s1">'java.util.ArrayList'</span>
<span class="n">java_import</span> <span class="s1">'javax.swing.JOptionPane'</span>

<span class="no">System</span><span class="p">.</span><span class="nf">out</span><span class="p">.</span><span class="nf">println</span><span class="p">(</span><span class="s2">"Feel the power of JRuby"</span><span class="p">)</span>

<span class="c1">## using snake_names for Java method names</span>
<span class="nb">puts</span> <span class="no">System</span><span class="p">.</span><span class="nf">current_time_millis</span>
<span class="c1">## regular names work as well</span>
<span class="nb">puts</span> <span class="no">System</span><span class="p">.</span><span class="nf">currentTimeMillis</span>

<span class="n">array_list</span> <span class="o">=</span> <span class="no">ArrayList</span><span class="p">.</span><span class="nf">new</span>

<span class="c1">## the array list supports some common Ruby idioms</span>
<span class="n">array_list</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span>
<span class="n">array_list</span><span class="p">.</span><span class="nf">add</span> <span class="mi">2</span>
<span class="n">array_list</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span>

<span class="nb">puts</span> <span class="s2">"List length is #</span><span class="si">#{</span><span class="n">array_list</span><span class="p">.</span><span class="nf">length</span><span class="si">}</span><span class="s2">"</span>

<span class="n">array_list</span><span class="p">.</span><span class="nf">each</span> <span class="p">{</span> <span class="o">|</span><span class="n">elem</span><span class="o">|</span> <span class="nb">puts</span> <span class="n">elem</span> <span class="p">}</span>

<span class="c1">## a glimpse of Swing</span>
<span class="no">JOptionPane</span><span class="p">.</span><span class="nf">show_message_dialog</span><span class="p">(</span><span class="kp">nil</span><span class="p">,</span> <span class="s2">"This is a message from the future of Ruby!"</span><span class="p">)</span>
</code></pre></div></div>

<p>You shouldn’t, of course, use ArrayList unless you’re using a Java API
that is requiring you to do so. Hopefully these simple examples gave
you an idea how easy it is to access Java code from JRuby.</p>

<p>It might be tempting to think of Java/Ruby integration as nothing more
than calling from one language to another. That’s not the case. In a
typical project, you’re really interacting with both platforms.  You
might construct a Ruby object, pass it to a Java function, and watch
the Java code call other Ruby methods you’ve defined. All the advanced
interactions are beyond the scope of this cursory overview, but you’re
definitely encouraged to explore them on your own.</p>

<h2 id="using-jruby-from-java">Using JRuby from Java</h2>

<p>While Java libraries are capable of doing just about anything they are
generally not as elegant as some of their Ruby counterparts. This might
make you want to run some Ruby code from a Java program. JRuby allows
you do this:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">org.jruby.embed.InvokeFailedException</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.jruby.embed.ScriptingContainer</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">RubyFromJava</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">ScriptingContainer</span> <span class="n">container</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ScriptingContainer</span><span class="o">();</span>
        <span class="n">container</span><span class="o">.</span><span class="na">runScriptlet</span><span class="o">(</span><span class="s">"puts 'Ruby bridge established successfully'"</span> <span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>This example is quite basic, but you should be able to grasp the basic
idea from it.</p>

<h2 id="compatibility-with-standard-ruby-and-performance">Compatibility with standard Ruby and performance</h2>

<p>JRuby 1.6 is mostly compatible with MRI Ruby 1.9.2. Since Ruby doesn’t
have a formal standard and is mostly defined in terms of the reference
implementation (although there are some compatibility test suites)
alternative implementations like JRuby are bound to be a step behind
the current reference version from time to time. JRuby, however,
catches up very quickly and has reached a state in popularity and adoption
at which I’m certain that they (the JRuby team) keep an open communication channel with
upstream MRI developers and are capable to add the new features with
very little delay.</p>

<p>In terms of performance JRuby is slightly faster in many tests than
MRI 1.9.2 and with the inclusion of support for dynamic method
dispatching in Java 7 (coming up later this year) the performance will
probably be improved significantly. The only real performance problem
is the JVM startup time. If you’re using JRuby to run very simple
scripts you might be mislead to believe that JRuby’s very slow, when actually the
delay you’re witnessing is caused by the JVM startup (which is not
very fast). Some Ruby features like ObjectSpace don’t perform very
well on the JVM as well, but they are used rarely.</p>

<p>In a sentence - JRuby is quite compatible with the standard MRI Ruby
and one of the fastest Ruby implementations around.</p>

<h2 id="deployment-options-and-future-prospects">Deployment options and future prospects</h2>

<p>With JRuby your number of deployment options vastly improves - now you
can deploy your Ruby applications anywhere where a JVM can be run (and
there are lot such places, believe me about that). With JRuby you can
deploy your Rails applications on the Google App Engine or in a Java
enterprise container such as Glassfish. You can also write mobile
applications for the Android operating system.</p>

<p>JRuby’s development is funded by a very solid company, called
<a href="http://www.engineyard.com/">“Engine Yard”</a> which is famous for its world class Rails hosting
solutions. The company obviously has a lot at stake here and you
shouldn’t be afraid that JRuby might die anytime soon.</p>

<p>IT consulting companies like
<a href="http://www.thoughtworks.com/">ThoughtWorks</a> have used JRuby to deliver both products and customer
applications on far more aggressive schedules than they could
have with more conventional languages</p>

<h2 id="the-tools-of-the-trade">The tools of the trade</h2>

<p>Most Ruby hackers tend to program without the aid of sophisticated
IDEs. Emacs, vim and TextMate are popular choices. Recently
<a href="http://www.sublimetext.com/">SublimeText</a> has been getting a fair share of attention as well. While
it’s fairly easy to write Ruby code in a text editor it’s generally a
nightmare to write Java code in an editor. Some of the most old-school
hardcore developers that I know bowed down before the complexity of
Java and started using Eclipse, NetBeans or IntelliJ to keep their
sanity intact. When you’re working on a project that’s a mixture of Ruby
and Java code it might be a good choice to opt for using some IDE as
well.</p>

<ul>
  <li><a href="http://www.jetbrains.com/idea/">IntelliJ IDEA</a> - The legendary Java IDE comes with a very capable
Ruby plug-in, that integrates well with Rails, the common templating
languages often used with it and most Ruby testing
frameworks. IntelliJ even has a variant for pure Ruby development
called <a href="http://www.jetbrains.com/ruby/">RubyMine</a> which is regarded by many devs as the best Ruby
IDE out there.</li>
  <li><a href="http://wiki.netbeans.org/RubySupport">NetBeans</a> - At some point the core JRuby team were employed by
Sun and at that time great Ruby support was added to
NetBeans. Oracle killed the official Ruby support in NetBeans 7.0,
but it’s still maintained as a community project. It’s not as good
as the one in RubyMine, but it doesn’t cost anything either.</li>
  <li><a href="http://www.eclipse.org/dltk/">Eclipse</a> - Eclipse has an official
Ruby plug-in(part of DLTK), but most people tend to prefer using
<a href="http://www.aptana.com/products/studio3">Aptana Studio</a> - a web
development IDE built on top of Eclipse.</li>
</ul>

<h2 id="epilogue">Epilogue</h2>

<p>JRuby is a solid addition to the ranks of JVM languages. Given the
fact that Ruby served as the principle inspiration for Groovy many
people will probably do better to use JRuby in preference to Groovy
(except the ones fond of the Java syntax I guess). I personally love
both Ruby and the JVM and for me JRuby was a match made in heaven. It
opens a lot new and exciting possibilities before one of the most
beautiful languages ever conceived.</p>

<p>I particularly like the ability to create portable GUIs with Swing and
the extended deployment options that JRuby provides. If Java 7 brings
the promised speed improvements I’m certain that JRuby will have a
shot at becoming the reigning Ruby implementation.</p>

<p>So what are you waiting for? Go grab a copy of the JRuby Bible
<a href="http://pragprog.com/titles/jruby/using-jruby">“Using JRuby”</a> and
start coding.</p>
:ET