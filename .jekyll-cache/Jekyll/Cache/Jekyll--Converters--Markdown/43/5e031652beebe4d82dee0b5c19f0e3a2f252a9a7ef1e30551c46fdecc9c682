I"Å<p><code class="language-plaintext highlighter-rouge">juxt</code> is one remarkably useful core Clojure function, that doesn‚Äôt
seem to be widely used (or understood for that matter), but is part of
the arsenal of every experienced Clojure hacker.</p>

<p>Looking at the official docs you‚Äôll see that <code class="language-plaintext highlighter-rouge">juxt</code> takes a set of
functions and returns a function that is the juxtaposition of those
functions. The returned function takes a variable number of
arguments, and returns a vector containing the result of applying each
function to the arguments (from left to right). Basically:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">((</span><span class="nf">juxt</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="n">c</span><span class="p">)</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="n">=&gt;</span><span class="w"> </span><span class="p">[(</span><span class="nf">a</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nf">b</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nf">c</span><span class="w"> </span><span class="n">x</span><span class="p">)]</span><span class="w">
</span></code></pre></div></div>

<p>At first glace that probably doesn‚Äôt seem particularly useful. Let‚Äôs
see some practical applications of <code class="language-plaintext highlighter-rouge">juxt</code>. What if we wanted to split
a sequence into two sequences - one with the values that satisfy some
predicate and one with the values that don‚Äôt. While there are many
ways to do so, <code class="language-plaintext highlighter-rouge">juxt</code> offers one particularly elegant:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">;; illustration of the general idea</span><span class="w">
</span><span class="p">((</span><span class="nf">juxt</span><span class="w"> </span><span class="nb">filter</span><span class="w"> </span><span class="nb">remove</span><span class="p">)</span><span class="w"> </span><span class="n">pred</span><span class="w"> </span><span class="n">coll</span><span class="p">)</span><span class="w">

</span><span class="c1">;; separate the even from the odd numbers</span><span class="w">
</span><span class="p">((</span><span class="nf">juxt</span><span class="w"> </span><span class="nb">filter</span><span class="w"> </span><span class="nb">remove</span><span class="p">)</span><span class="w"> </span><span class="n">even?</span><span class="w"> </span><span class="p">(</span><span class="nb">range</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">10</span><span class="p">))</span><span class="w">
</span><span class="c1">;; =&gt; [(2 4 6 8) (1 3 5 7 9)]</span><span class="w">
</span></code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">juxt</code> is also quite helpful when dealing with multiple map keys:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">;; extract the values of a couple of maps keys</span><span class="w">
</span><span class="p">((</span><span class="nf">juxt</span><span class="w"> </span><span class="no">:alias</span><span class="w"> </span><span class="no">:name</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="no">:alias</span><span class="w"> </span><span class="s">"Batman"</span><span class="w"> </span><span class="no">:name</span><span class="w"> </span><span class="s">"Bruce Wayne"</span><span class="p">})</span><span class="w">
</span><span class="c1">;; =&gt; ["Batman" "Bruce Wayne"]</span><span class="w">

</span><span class="c1">;; sort a vector of maps by a composite criteria</span><span class="w">
</span><span class="p">(</span><span class="nb">sort-by</span><span class="w"> </span><span class="p">(</span><span class="nf">juxt</span><span class="w"> </span><span class="no">:alias</span><span class="w"> </span><span class="no">:name</span><span class="p">)</span><span class="w">
         </span><span class="p">[{</span><span class="no">:alias</span><span class="w"> </span><span class="s">"Batman"</span><span class="w"> </span><span class="no">:name</span><span class="w"> </span><span class="s">"Bruce Wayne"</span><span class="p">}</span><span class="w">
          </span><span class="p">{</span><span class="no">:alias</span><span class="w"> </span><span class="s">"Robin"</span><span class="w"> </span><span class="no">:name</span><span class="w"> </span><span class="s">"Jason Todd"</span><span class="p">}</span><span class="w">
          </span><span class="p">{</span><span class="no">:alias</span><span class="w"> </span><span class="s">"Robin"</span><span class="w"> </span><span class="no">:name</span><span class="w"> </span><span class="s">"Tim Drake"</span><span class="p">}</span><span class="w">
          </span><span class="p">{</span><span class="no">:alias</span><span class="w"> </span><span class="s">"Robin"</span><span class="w"> </span><span class="no">:name</span><span class="w"> </span><span class="s">"Dick Grayson"</span><span class="p">}])</span><span class="w">

</span><span class="c1">;; =&gt; ({:name "Bruce Wayne", :alias "Batman"} {:name "Dick Grayson", :alias "Robin"} {:name "Jason Todd", :alias "Robin"} {:name "Tim Drake", :alias "Robin"})</span><span class="w">
</span></code></pre></div></div>

<p>Hopefully this short article has whetted your appetite and you‚Äôll find
even more elegant uses for <code class="language-plaintext highlighter-rouge">juxt</code> in your code.</p>
:ET