I"ÖM<h2 id="prelude">Prelude</h2>

<p>Let‚Äôs face it - although a vanilla Emacs installation is quite
powerful almost nobody is using Emacs without a pile of add-ons. And
managing those add-ons is quite frankly a pain in the ass. Traditional
options included installing Emacs add-ons via the operating system‚Äôs
package manager (if available), downloading <code class="language-plaintext highlighter-rouge">.el</code> files from various
locations (everybody hates packages distributed only on Emacs Wiki
with no canonical version control repo) and simply sticking them on
the <code class="language-plaintext highlighter-rouge">load-path</code>, etc. It‚Äôs more than obvious that such solutions are
less than ideal.</p>

<p>For instance if you‚Äôre installing Emacs add-ons via a package manager
and you have to change OSes (or machines) you‚Äôre mostly fucked. On the
other hand piling files manually in <code class="language-plaintext highlighter-rouge">.emacs.d</code> is equal to hell in the
version and dependency tracking department. There has to be a better
way, right? Wouldn‚Äôt it be nice if Emacs had its own package manager
similar to the likes of <code class="language-plaintext highlighter-rouge">homebrew</code>, <code class="language-plaintext highlighter-rouge">apt</code> or <code class="language-plaintext highlighter-rouge">yum</code>?</p>

<p><a href="/articles/2011/08/19/a-peek-at-emacs24/">Emacs 24</a>
finally introduces such a tool - its name is <code class="language-plaintext highlighter-rouge">package.el</code> (very
original, right?) and its promise is to make your lives a bit
easier. Does it manage to deliver on that promise? We‚Äôll see that in a bit‚Ä¶</p>

<!--more-->

<h2 id="package-management-with-packageel">Package management with package.el</h2>

<p><code class="language-plaintext highlighter-rouge">package.el</code> is bundled with Emacs 24, but it‚Äôs not bound to Emacs</p>
<ol>
  <li>Before it became part of Emacs it was an external package, known
as ELPA (I guess that stood for Emacs Lisp Package Manager or
something similar). So even if you‚Äôre an Emacs 23 user you can copy
the latest version of <code class="language-plaintext highlighter-rouge">package.el</code> from
<a href="http://repo.or.cz/w/emacs.git/blob_plain/1a0a666f941c99882093d7bd08ced15033bc3f0c:/lisp/emacs-lisp/package.el">here</a>
and enjoy it. At this point you‚Äôll have to do something like:</li>
</ol>

<div class="language-elisp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nb">require</span> <span class="ss">'package</span><span class="p">)</span>
<span class="p">(</span><span class="nv">package-initialize</span><span class="p">)</span>
</code></pre></div></div>

<p>Put this snippet of code near the beginning of your Emacs config,
since you‚Äôll definitely want packages installed via <code class="language-plaintext highlighter-rouge">package.el</code> to be
initalized <em>before</em> you start tweaking them.</p>

<p>What <code class="language-plaintext highlighter-rouge">package.el</code> basically does is that it connects to a list of
package repositories, retrieves the list of the packages there,
presents it to you in a interactive fashion and lets you install the
packages you like (of course you can also remove the once you don‚Äôt
like). <code class="language-plaintext highlighter-rouge">package.el</code> understands the dependencies between packages and
if one package requires others to run they will be installed
automatically (which is really neat).</p>

<p>The magic starts with the command <code class="language-plaintext highlighter-rouge">M-x package-list-packages</code>. At this
point you should see something in the lines of this.</p>

<p><img src="/assets/images/packages-list.png" alt="packages list" /></p>

<p>You can navigate the list of packages, mark the ones you want to
install with the ‚Äúi‚Äù key or the ones you want removed with the ‚Äúd‚Äù key
and when you‚Äôre done you can press the ‚Äúx‚Äù key to execute the
scheduled actions.</p>

<p>Initially <code class="language-plaintext highlighter-rouge">package.el</code> didn‚Äôt provide the option to update a package,
but that should be fixed in recent Emacs builds. According to this
<a href="http://lists.gnu.org/archive/html/emacs-devel/2011-09/msg00371.html">thread</a>
you can even update all of the installed packages by using the ‚ÄúU‚Äù key
in the packages list view (I guess that a small ‚Äúu‚Äù would update only
one package). Unfortunately my build is lacking those capabilities so
I cannot comment of their usability.</p>

<p>You‚Äôd probably notice that your list of available packages is not
particularly long. That‚Äôs because the official Emacs 24 package
repository has a strict licensing (and source code) requirements to
include a package there. Luckily there are a number of
community-maintained <code class="language-plaintext highlighter-rouge">package.el</code> repos around with much more relaxed
requirements. Probably the most popular of them is
<a href="http://marmalade-repo.org/">Marmalade</a>, created by
<a href="http://nex-3.com/">Nathan Weizenbaum</a> of Sass and Haml fame. You can
include it in your <code class="language-plaintext highlighter-rouge">package-archives</code> list like this:</p>

<div class="language-elisp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nv">add-to-list</span> <span class="ss">'package-archives</span>
             <span class="o">'</span><span class="p">(</span><span class="s">"marmalade"</span> <span class="o">.</span> <span class="s">"http://marmalade-repo.org/packages/"</span><span class="p">)</span> <span class="no">t</span><span class="p">)</span>
</code></pre></div></div>

<p>Marmalade provides a web based UI for package upload and search (both
quite buggy unfortunately) and the ability to share the maintenance of
a package between several people, who‚Äôll be able to upload new version
of the package. There‚Äôs also a Emacs Lisp Marmalade tool, that allows
you to submit packages directly from Emacs.</p>

<p>Using the <code class="language-plaintext highlighter-rouge">package.el</code> UI is ok if you‚Äôre a casual Emacs user, but
what if you have a custom Emacs configuration, stored under version
control, that you‚Äôd like to instantly deploy on any OS/machine (like
Emacs Prelude). Here in play comes <code class="language-plaintext highlighter-rouge">package.el</code>‚Äôs programmer
interface. In
<a href="https://github.com/bbatsov/prelude">Emacs Prelude</a> I use the
following code to install a list of required packages automatically on Emacs
startup (if necessary):</p>

<div class="language-elisp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nb">defvar</span> <span class="nv">prelude-packages</span>
  <span class="o">'</span><span class="p">(</span><span class="nv">ack-and-a-half</span> <span class="nv">auctex</span> <span class="nv">clojure-mode</span> <span class="nv">coffee-mode</span> <span class="nv">deft</span> <span class="nv">expand-region</span>
                   <span class="nv">gist</span> <span class="nv">groovy-mode</span> <span class="nv">haml-mode</span> <span class="nv">haskell-mode</span> <span class="nv">inf-ruby</span>
                   <span class="nv">magit</span> <span class="nv">magithub</span> <span class="nv">markdown-mode</span> <span class="nv">paredit</span> <span class="nv">projectile</span> <span class="nv">python</span>
                   <span class="nv">sass-mode</span> <span class="nv">rainbow-mode</span> <span class="nv">scss-mode</span> <span class="nv">solarized-theme</span>
                   <span class="nv">volatile-highlights</span> <span class="nv">yaml-mode</span> <span class="nv">yari</span> <span class="nv">zenburn-theme</span><span class="p">)</span>
  <span class="s">"A list of packages to ensure are installed at launch."</span><span class="p">)</span>

<span class="p">(</span><span class="nb">defun</span> <span class="nv">prelude-packages-installed-p</span> <span class="p">()</span>
  <span class="p">(</span><span class="nb">loop</span> <span class="nv">for</span> <span class="nv">p</span> <span class="nv">in</span> <span class="nv">prelude-packages</span>
        <span class="nb">when</span> <span class="p">(</span><span class="nb">not</span> <span class="p">(</span><span class="nv">package-installed-p</span> <span class="nv">p</span><span class="p">))</span> <span class="nb">do</span> <span class="p">(</span><span class="nb">return</span> <span class="no">nil</span><span class="p">)</span>
        <span class="nv">finally</span> <span class="p">(</span><span class="nb">return</span> <span class="no">t</span><span class="p">)))</span>

<span class="p">(</span><span class="nb">unless</span> <span class="p">(</span><span class="nv">prelude-packages-installed-p</span><span class="p">)</span>
  <span class="c1">;; check for new packages (package versions)</span>
  <span class="p">(</span><span class="nv">message</span> <span class="s">"%s"</span> <span class="s">"Emacs Prelude is now refreshing its package database..."</span><span class="p">)</span>
  <span class="p">(</span><span class="nv">package-refresh-contents</span><span class="p">)</span>
  <span class="p">(</span><span class="nv">message</span> <span class="s">"%s"</span> <span class="s">" done."</span><span class="p">)</span>
  <span class="c1">;; install the missing packages</span>
  <span class="p">(</span><span class="nb">dolist</span> <span class="p">(</span><span class="nv">p</span> <span class="nv">prelude-packages</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">when</span> <span class="p">(</span><span class="nb">not</span> <span class="p">(</span><span class="nv">package-installed-p</span> <span class="nv">p</span><span class="p">))</span>
      <span class="p">(</span><span class="nv">package-install</span> <span class="nv">p</span><span class="p">))))</span>

<span class="p">(</span><span class="nb">provide</span> <span class="ss">'prelude-packages</span><span class="p">)</span>
<span class="c1">;;; prelude-packages.el ends here</span>
</code></pre></div></div>

<p>This code check if all of the packages in the list are installed and
if any of them are not installed if refreshes the local package
database (in the case a required package for recently added to the remote
repo) and installs them.</p>

<p>To be able to publish a package to Marmalade (or another repo) it
should comform a standardized structure. A single-file package might look like this:</p>

<div class="language-elisp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">;;; sass-mode.el --- Sass major mode</span>

<span class="c1">;; Copyright 2007-2010 Nathan Weizenbaum</span>

<span class="c1">;; Author: Nathan Weizenbaum &lt;nex342@gmail.com&gt;</span>
<span class="c1">;; URL: http://github.com/nex3/sass-mode</span>
<span class="c1">;; Version: 3.0.20</span>
<span class="c1">;; Package-Requires: ((haml-mode "3.0.20"))</span>

<span class="c1">;; Code goes here</span>

<span class="c1">;;; sass-mode.el ends here</span>
</code></pre></div></div>

<p>A multi-file package should have an additional file named
<code class="language-plaintext highlighter-rouge">&lt;name&gt;-pkg.el</code> that should look like this:</p>

<div class="language-elisp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nv">define-package</span> <span class="s">"sass-mode"</span> <span class="s">"3.0.20"</span>
                <span class="s">"Sass major mode"</span>
                <span class="o">'</span><span class="p">((</span><span class="nv">haml-mode</span> <span class="s">"3.0.20"</span><span class="p">)))</span>

</code></pre></div></div>

<h2 id="the-bad-and-the-ugly">The Bad and the Ugly</h2>

<p>While <code class="language-plaintext highlighter-rouge">package.el</code> is great on paper, for it to really take off some
problems need to be resolved.</p>

<h4 id="updating-should-be-easy">Updating should be easy</h4>

<p>One of the best features of OS package managers is that they make it
really easy to update all of the installed packages to their latest
versions. Currently <code class="language-plaintext highlighter-rouge">package.el</code> doesn‚Äôt support that (at least to my
knowledge), with the exception of the ‚ÄúU‚Äù key in the list packages
view. This seems to me like a pretty basic feature and I (and everyone
I‚Äôve talked with) would really like to see it in Emacs 24 final.</p>

<h4 id="too-much-is-riding-on-marmalade">Too much is riding on Marmalade</h4>

<p>Marmalade has become extremely important in the recent months and the
list of packages there is growing every day. This would have normally
filled me with great joy, if it weren‚Äôt for a few problems.</p>

<p>It seems that the project isn‚Äôt getting much attention from its maintainer
(which is understandable, given the fact that he‚Äôs maintaining several
high profile projects + the fact he‚Äôs a full time Google
employee). As a result Marmalade is quite buggy (especially in the UI
department) and is missing key features, like the ability to contact a
package maintainer. At some point it was even lacking the ability to
delete a package. Uploads don‚Äôt work reliably there, package refresh
sometimes yields http errors that require manual <code class="language-plaintext highlighter-rouge">M-x
package-refresh-contents</code> and from time to time there is even downtime
of the service.</p>

<p>The fact that its backend is written in Node.js (great technology, but
not widely understood for now) and hosted on Google
Code, doesn‚Äôt improve the situation a lot. A Ruby or Python based
solution hosted on GitHub would certainly gain much more traction in
the community (and I‚Äôm planning to start work on one soon).</p>

<h4 id="scarce-documentation">Scarce documentation</h4>

<p><code class="language-plaintext highlighter-rouge">package.el</code> is light on the documentation and you‚Äôll have to explore
its source code if you want to implement its required interface
(which luckily is very simple). I hope this will change by the release
of Emacs 24.</p>

<h4 id="too-few-package-authors-care-about-packageel">Too few package authors care about package.el</h4>

<p>Package authors rarely tag versions that could be uploaded to a
<code class="language-plaintext highlighter-rouge">package.el</code> compatible repo and from time to time don‚Äôt follow the
basic structure required. I always contact package authors to let them
know of such shortcomings in their packages and so should you.</p>

<h2 id="alternatives">Alternatives</h2>

<p><a href="https://github.com/dimitri/el-get">el-get</a> is another popular Emacs
add-ons management solution that has recently become popular.</p>

<p>el-get allows you to install and manage elisp code for Emacs. It
supports lots of differents types of sources (git, svn, apt, elpa,
etc) and is able to install them, update them and remove them, but
more importantly it will init them for you.</p>

<p>That means it will require the features you need, load the necessary
files, set the Info paths so that <code class="language-plaintext highlighter-rouge">C-h i</code> shows the new documentation
you now depend on, and finally call your own <code class="language-plaintext highlighter-rouge">:post-init</code> function for
you to setup the extension. Or call it a package.</p>

<p>el-get is inherently troublesome piece of software on Windows machines
and was originally designed to make it simple to obtain the latest
versions of packages from git - a practice which I profoundly
dislike. Master package branches are often buggy (but there are also
authors that never tag versions and rely on the rolling release model)
and I‚Äôm generally supportive of the stable version releases. While
some view it as a nice addition to <code class="language-plaintext highlighter-rouge">package.el</code> I feel that el-get is
too low level tool (in its approach to the problem) and should be
avoided.</p>

<p><strong>Update</strong></p>

<p>A few hours after I posted this article it got a nice lengthy comment
by el-get‚Äôs author. Since I believe, that the comment is quite
interesting I‚Äôm adding it here without any alterations.</p>

<blockquote>
  <p>As the author of el-get, good article!  The Emacs extension situation
is far from ideal and needs hard critics so that work is done to
improve it.</p>

  <p>I now want to share with you some of the features that are currently
only available in the development branch of el-get (soon to be
released as 4.1): you can now easily checkout a stable branch from a
git repository (thanks to the :checkout property) and you can even
setup which checksum you want installed.So when using git, the
checksum is in fact a revision, when using emacswiki you have to
compute the checksum (doing M-x el-get-checksum) and register it in
your el-get-sources setup, then if the file change on emacswiki el-get
will refuse loading it (hopefully until you‚Äôve done your review then
updated the checksum).So while I perfectly understand your reserve
toward depending on el-get, I believe that your concerns are being
solved now.I would like to believe that authors of emacs lisp scripts
would take the time to consider formatting their sources for
package.el. Today it‚Äôs far from granted, so by choosing ELPA you miss
a lot of things. And for the situation to change you need to have the
authors willing to package their extensions, or you have to fork their
work. With el-get you have access to 536 packages from the get-go, and
all of emacswiki (that‚Äôs currently more than 1700 packages) after
you‚Äôve done M-x el-get-emacswiki-refresh. As of writing this comment,
my M-x el-get-package-list contains 2106 packages ready to install,
almost all with descriptions.el-get is about social packaging where
it‚Äôs easy to prepare a recipe for a package, whatever distribution
means its author picked. Then you can share that recipe very easily,
for example with el-get on github where we‚Äôll be happy to add your
work and have it installed by default when users either install el-get
or do M-x el-get-self-update.As for windows support, it all depends on
the packages you want to install. Most of them just work out of the
box, being a single emacs lisp file (.el). Some of them require to
have extra tools installed, from git or svn or mercurial to make and
autoconf. That‚Äôs only how the authors are shipping their extensions
though, el-get is only providing for an integrated way to get at it.
We have accepted several improvements so that the windows experience
matches the others OS, and we consider windows a first class citizen
here.</p>

  <p>‚Äì Dimitri Fontaine, Author of el-get</p>
</blockquote>

<h2 id="epilogue">Epilogue</h2>

<p><code class="language-plaintext highlighter-rouge">package.el</code> is the future of Emacs add-on management - of that I‚Äôm
quite certain. It‚Äôs far from perfect, but even in its present flawed
form it has already simplified the life of many Emacs users
immensely. I urge all of you to stop distributing Emacs packages via
sources such as the Emacs Wiki and to put a heavy emphasis on
<code class="language-plaintext highlighter-rouge">package.el</code>. Make your packages compatible with it, upload them to a
community maintained repo (or the official if possible) and keep them
up-to-date. Your users will love you for that!</p>

<p>I‚Äôd like to see a replacement to Marmalade in the future as well. A
more robust and polished solution, maintained by a team of several
people. Hopefully that moment is not that far in the future.</p>
:ET