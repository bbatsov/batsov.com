I"w<p>From time to time we need to rename a bunch of files according to some
pattern.  One simple example that comes to mind is that recently I
noticed that some articles in my blog had a <code class="language-plaintext highlighter-rouge">.md</code> extension and some
had a <code class="language-plaintext highlighter-rouge">.markdown</code> extension. I don’t like inconsistencies, so I wanted
them all to have a <code class="language-plaintext highlighter-rouge">.md</code> extension. Bellow I’ll cover several ways to
do this on Linux<sup id="fnref:1" role="doc-noteref"><a href="#fn:1" class="footnote" rel="footnote">1</a></sup>. All the examples will assume you’re renaming
files in the same folder, but it’s typically trivial to extend them to
a directory tree by combining a command with <code class="language-plaintext highlighter-rouge">find -exec</code> or extended
globbing (e.g. <code class="language-plaintext highlighter-rouge">**/*.markdown</code>). So, here we go.</p>

<p>One simple option is to use the <code class="language-plaintext highlighter-rouge">rename</code> utility from the <code class="language-plaintext highlighter-rouge">util-linux</code> package:</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>rename markdown md <span class="k">*</span>.markdown
</code></pre></div></div>

<p>Basically you’re doing a text substitution in the list of files passed
to the command. The problem with this is that it won’t work properly
in cases like <code class="language-plaintext highlighter-rouge">markdown.markdown</code>. Fortunately, Debian and Debian-derived
distributions (e.g. Ubuntu) ship a more powerful version of this command, that’s
written in Perl, and supports regular expressions.</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">sudo </span>apt <span class="nb">install </span>rename
<span class="nv">$ </span>rename <span class="s1">'s/\.markdown$/.md/'</span> <span class="k">*</span>.markdown
</code></pre></div></div>

<p>The regular expression allows us to be specific about the match and prevents the problem listed above.
By the way, generally it’s a good idea to first preview any changes that the command might perform with the <code class="language-plaintext highlighter-rouge">-n</code> option:</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>rename <span class="nt">-n</span> <span class="s1">'s/\.markdown$/.md/'</span> <span class="k">*</span>.markdown
rename<span class="o">(</span>2008-05-05-first-post.markdown, 2008-05-05-first-post.md<span class="o">)</span>
rename<span class="o">(</span>2008-06-16-das-keyboard.markdown, 2008-06-16-das-keyboard.md<span class="o">)</span>
rename<span class="o">(</span>2008-06-19-emacs-rails.markdown, 2008-06-19-emacs-rails.md<span class="o">)</span>
rename<span class="o">(</span>2008-07-27-zsh-prompt.markdown, 2008-07-27-zsh-prompt.md<span class="o">)</span>
rename<span class="o">(</span>2008-09-29-singleton-java-ruby.markdown, 2008-09-29-singleton-java-ruby.md<span class="o">)</span>
rename<span class="o">(</span>2009-05-04-switch-string-idiom-java.markdown, 2009-05-04-switch-string-idiom-java.md<span class="o">)</span>
</code></pre></div></div>

<p>Super handy!</p>

<p>If you don’t want to use an external command you can leverage some shell features instead:</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="k">for </span>f <span class="k">in</span> <span class="k">*</span>.markdown<span class="p">;</span> <span class="k">do
    </span><span class="nb">mv</span> <span class="nt">--</span> <span class="s2">"</span><span class="nv">$f</span><span class="s2">"</span> <span class="s2">"</span><span class="k">${</span><span class="nv">f</span><span class="p">%.markdown</span><span class="k">}</span><span class="s2">.md"</span>
<span class="k">done</span>
</code></pre></div></div>

<p>This relies on some relatively advanced substitution features of Bash
and Zsh, that are beyond the scope of today’s article, but it gets the
job done. Interestingly enough, Zsh provides a much simpler and way more powerful way to tackle mass rename, via
the <code class="language-plaintext highlighter-rouge">zmv</code> utility it bundles:</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>zmv <span class="s1">'(*).markdown'</span> <span class="s1">'$1.md'</span>
</code></pre></div></div>

<p>While <code class="language-plaintext highlighter-rouge">zmv</code> doesn’t use regular expressions, it’s matching and substitution functionality should cover pretty much
everything you decide to throw at it.
Note that <code class="language-plaintext highlighter-rouge">zmv</code> is usually not enabled by default and you might have to load it manually before using it:</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>autoload <span class="nt">-Uz</span> zmv
</code></pre></div></div>

<p>Notice also that in the first argument of <code class="language-plaintext highlighter-rouge">zmv</code> you’ve specifying both the search pattern for files and substitution groups
you can use in the second argument. You can do way more complex renamings with <code class="language-plaintext highlighter-rouge">zmv</code>:</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># rename dir1/file.txt, dir2/file.txt, etc to file-1.txt, file-2.txt, etc</span>
<span class="nv">$ </span>zmv zmv <span class="s1">'dir(*)/file.txt'</span> <span class="s1">'file-${1}.txt'</span>
</code></pre></div></div>

<p>Obviously sky is the limit here, although this applies to the Perl version of the <code class="language-plaintext highlighter-rouge">rename</code> command as well.
One cool thing about <code class="language-plaintext highlighter-rouge">zmv</code> is that you just like with <code class="language-plaintext highlighter-rouge">rename</code> you can preview the changes it’s going to do with the <code class="language-plaintext highlighter-rouge">-n</code> option.</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>zmv <span class="nt">-n</span> <span class="s1">'(*).markdown'</span> <span class="s1">'$1.md'</span>
</code></pre></div></div>

<p>This will help you to quickly find the right pattern for the mass rename you’re trying to perform.</p>

<p>That’s all I have for you today. I’ve barely scratched the surface of
what’s possible, but I still hope you learned something new and
useful. Keep hacking!</p>

<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:1" role="doc-endnote">
      <p>Most of those suggestions should also work on other Unix-like operating systems like macOS, *BSD, etc. <a href="#fnref:1" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>
:ET